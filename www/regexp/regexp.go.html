<!doctype html>
<html>

<head>
	<meta charset="utf-8" />
	<title>Go standard library</title>
	<link rel="stylesheet" type="text/css" href="/style.css">
</head>

<body>

<div class="code">
<span class="lineno">1</span><span class="comment">//&nbsp;Copyright&nbsp;2009&nbsp;The&nbsp;Go&nbsp;Authors.&nbsp;All&nbsp;rights&nbsp;reserved.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;Use&nbsp;of&nbsp;this&nbsp;source&nbsp;code&nbsp;is&nbsp;governed&nbsp;by&nbsp;a&nbsp;BSD-style</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;license&nbsp;that&nbsp;can&nbsp;be&nbsp;found&nbsp;in&nbsp;the&nbsp;LICENSE&nbsp;file.</span><br>
<span class="lineno"></span><br>
<span class="lineno">5</span><span class="comment">//&nbsp;Package&nbsp;regexp&nbsp;implements&nbsp;regular&nbsp;expression&nbsp;search.</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;The&nbsp;syntax&nbsp;of&nbsp;the&nbsp;regular&nbsp;expressions&nbsp;accepted&nbsp;is&nbsp;the&nbsp;same</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;general&nbsp;syntax&nbsp;used&nbsp;by&nbsp;Perl,&nbsp;Python,&nbsp;and&nbsp;other&nbsp;languages.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;More&nbsp;precisely,&nbsp;it&nbsp;is&nbsp;the&nbsp;syntax&nbsp;accepted&nbsp;by&nbsp;RE2&nbsp;and&nbsp;described&nbsp;at</span><br>
<span class="lineno">10</span><span class="comment">//&nbsp;http://code.google.com/p/re2/wiki/Syntax,&nbsp;except&nbsp;for&nbsp;\C.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;For&nbsp;an&nbsp;overview&nbsp;of&nbsp;the&nbsp;syntax,&nbsp;run</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;&nbsp;&nbsp;godoc&nbsp;regexp/syntax</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;The&nbsp;regexp&nbsp;implementation&nbsp;provided&nbsp;by&nbsp;this&nbsp;package&nbsp;is</span><br>
<span class="lineno">15</span><span class="comment">//&nbsp;guaranteed&nbsp;to&nbsp;run&nbsp;in&nbsp;time&nbsp;linear&nbsp;in&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;input.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;(This&nbsp;is&nbsp;a&nbsp;property&nbsp;not&nbsp;guaranteed&nbsp;by&nbsp;most&nbsp;open&nbsp;source</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;implementations&nbsp;of&nbsp;regular&nbsp;expressions.)&nbsp;For&nbsp;more&nbsp;information</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;about&nbsp;this&nbsp;property,&nbsp;see</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;&nbsp;&nbsp;&nbsphttp://swtch.com/~rsc/regexp/regexp1.html</span><br>
<span class="lineno">20</span><span class="comment">//&nbsp;or&nbsp;any&nbsp;book&nbsp;about&nbsp;automata&nbsp;theory.</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;All&nbsp;characters&nbsp;are&nbsp;UTF-8-encoded&nbsp;code&nbsp;points.</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;There&nbsp;are&nbsp;16&nbsp;methods&nbsp;of&nbsp;Regexp&nbsp;that&nbsp;match&nbsp;a&nbsp;regular&nbsp;expression&nbsp;and&nbsp;identify</span><br>
<span class="lineno">25</span><span class="comment">//&nbsp;the&nbsp;matched&nbsp;text.&nbsp;&nbsp;Their&nbsp;names&nbsp;are&nbsp;matched&nbsp;by&nbsp;this&nbsp;regular&nbsp;expression:</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;&nbsp;&nbsp;&nbspFind(All)?(String)?(Submatch)?(Index)?</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;If&nbsp;&#39;All&#39;&nbsp;is&nbsp;present,&nbsp;the&nbsp;routine&nbsp;matches&nbsp;successive&nbsp;non-overlapping</span><br>
<span class="lineno">30</span><span class="comment">//&nbsp;matches&nbsp;of&nbsp;the&nbsp;entire&nbsp;expression.&nbsp;&nbsp;Empty&nbsp;matches&nbsp;abutting&nbsp;a&nbsp;preceding</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;match&nbsp;are&nbsp;ignored.&nbsp;&nbsp;The&nbsp;return&nbsp;value&nbsp;is&nbsp;a&nbsp;slice&nbsp;containing&nbsp;the&nbsp;successive</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;return&nbsp;values&nbsp;of&nbsp;the&nbsp;corresponding&nbsp;non-&#39;All&#39;&nbsp;routine.&nbsp;&nbsp;These&nbsp;routines&nbsp;take</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;an&nbsp;extra&nbsp;integer&nbsp;argument,&nbsp;n;&nbsp;if&nbsp;n&nbsp;&gt;=&nbsp;0,&nbsp;the&nbsp;function&nbsp;returns&nbsp;at&nbsp;most&nbsp;n</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;matches/submatches.</span><br>
<span class="lineno">35</span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;If&nbsp;&#39;String&#39;&nbsp;is&nbsp;present,&nbsp;the&nbsp;argument&nbsp;is&nbsp;a&nbsp;string;&nbsp;otherwise&nbsp;it&nbsp;is&nbsp;a&nbsp;slice</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;of&nbsp;bytes;&nbsp;return&nbsp;values&nbsp;are&nbsp;adjusted&nbsp;as&nbsp;appropriate.</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;If&nbsp;&#39;Submatch&#39;&nbsp;is&nbsp;present,&nbsp;the&nbsp;return&nbsp;value&nbsp;is&nbsp;a&nbsp;slice&nbsp;identifying&nbsp;the</span><br>
<span class="lineno">40</span><span class="comment">//&nbsp;successive&nbsp;submatches&nbsp;of&nbsp;the&nbsp;expression.&nbsp;Submatches&nbsp;are&nbsp;matches&nbsp;of</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;parenthesized&nbsp;subexpressions&nbsp;(also&nbsp;known&nbsp;as&nbsp;capturing&nbsp;groups)&nbsp;within&nbsp;the</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;regular&nbsp;expression,&nbsp;numbered&nbsp;from&nbsp;left&nbsp;to&nbsp;right&nbsp;in&nbsp;order&nbsp;of&nbsp;opening</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;parenthesis.&nbsp;Submatch&nbsp;0&nbsp;is&nbsp;the&nbsp;match&nbsp;of&nbsp;the&nbsp;entire&nbsp;expression,&nbsp;submatch&nbsp;1</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;the&nbsp;match&nbsp;of&nbsp;the&nbsp;first&nbsp;parenthesized&nbsp;subexpression,&nbsp;and&nbsp;so&nbsp;on.</span><br>
<span class="lineno">45</span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;If&nbsp;&#39;Index&#39;&nbsp;is&nbsp;present,&nbsp;matches&nbsp;and&nbsp;submatches&nbsp;are&nbsp;identified&nbsp;by&nbsp;byte&nbsp;index</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;pairs&nbsp;within&nbsp;the&nbsp;input&nbsp;string:&nbsp;result[2*n:2*n+1]&nbsp;identifies&nbsp;the&nbsp;indexes&nbsp;of</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;the&nbsp;nth&nbsp;submatch.&nbsp;&nbsp;The&nbsp;pair&nbsp;for&nbsp;n==0&nbsp;identifies&nbsp;the&nbsp;match&nbsp;of&nbsp;the&nbsp;entire</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;expression.&nbsp;&nbsp;If&nbsp;&#39;Index&#39;&nbsp;is&nbsp;not&nbsp;present,&nbsp;the&nbsp;match&nbsp;is&nbsp;identified&nbsp;by&nbsp;the</span><br>
<span class="lineno">50</span><span class="comment">//&nbsp;text&nbsp;of&nbsp;the&nbsp;match/submatch.&nbsp;&nbsp;If&nbsp;an&nbsp;index&nbsp;is&nbsp;negative,&nbsp;it&nbsp;means&nbsp;that</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;subexpression&nbsp;did&nbsp;not&nbsp;match&nbsp;any&nbsp;string&nbsp;in&nbsp;the&nbsp;input.</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;There&nbsp;is&nbsp;also&nbsp;a&nbsp;subset&nbsp;of&nbsp;the&nbsp;methods&nbsp;that&nbsp;can&nbsp;be&nbsp;applied&nbsp;to&nbsp;text&nbsp;read</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;from&nbsp;a&nbsp;RuneReader:</span><br>
<span class="lineno">55</span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;&nbsp;&nbsp;&nbspMatchReader,&nbsp;FindReaderIndex,&nbsp;FindReaderSubmatchIndex</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;This&nbsp;set&nbsp;may&nbsp;grow.&nbsp;&nbsp;Note&nbsp;that&nbsp;regular&nbsp;expression&nbsp;matches&nbsp;may&nbsp;need&nbsp;to</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;examine&nbsp;text&nbsp;beyond&nbsp;the&nbsp;text&nbsp;returned&nbsp;by&nbsp;a&nbsp;match,&nbsp;so&nbsp;the&nbsp;methods&nbsp;that</span><br>
<span class="lineno">60</span><span class="comment">//&nbsp;match&nbsp;text&nbsp;from&nbsp;a&nbsp;RuneReader&nbsp;may&nbsp;read&nbsp;arbitrarily&nbsp;far&nbsp;into&nbsp;the&nbsp;input</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;before&nbsp;returning.</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;(There&nbsp;are&nbsp;a&nbsp;few&nbsp;other&nbsp;methods&nbsp;that&nbsp;do&nbsp;not&nbsp;match&nbsp;this&nbsp;pattern.)</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno">65</span><span class="keyword">package</span>&nbsp;<span class="ident">regexp</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">import</span>&nbsp;<span class="op">(</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="string">&#34;bytes&#34;</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="string">&#34;io&#34;</span><br>
<span class="lineno">70</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="string">&#34;regexp/syntax&#34;</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="string">&#34;strconv&#34;</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="string">&#34;strings&#34;</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="string">&#34;sync&#34;</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="string">&#34;unicode&#34;</span><br>
<span class="lineno">75</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="string">&#34;unicode/utf8&#34;</span><br>
<span class="lineno"></span><span class="op">)</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">var</span>&nbsp;<span class="ident">debug</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">false</span><br>
<span class="lineno"></span><br>
<span class="lineno">80</span><span class="comment">//&nbsp;Regexp&nbsp;is&nbsp;the&nbsp;representation&nbsp;of&nbsp;a&nbsp;compiled&nbsp;regular&nbsp;expression.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;A&nbsp;Regexp&nbsp;is&nbsp;safe&nbsp;for&nbsp;concurrent&nbsp;use&nbsp;by&nbsp;multiple&nbsp;goroutines.</span><br>
<span class="lineno"></span><span class="keyword">type</span>&nbsp;<span class="ident">Regexp</span>&nbsp;<span class="keyword">struct</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;read-only&nbsp;after&nbsp;Compile</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">expr</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="builtintype">string</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;as&nbsp;passed&nbsp;to&nbsp;Compile</span><br>
<span class="lineno">85</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">prog</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="op">*</span><span class="ident">syntax</span><span class="op">.</span><span class="ident">Prog</span>&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;compiled&nbsp;program</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">onepass</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="op">*</span><span class="ident">onePassProg</span>&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;onpass&nbsp;program&nbsp;or&nbsp;nil</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">prefix</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="builtintype">string</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;required&nbsp;prefix&nbsp;in&nbsp;unanchored&nbsp;matches</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">prefixBytes</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;prefix,&nbsp;as&nbsp;a&nbsp;[]byte</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">prefixComplete</span>&nbsp;<span class="builtintype">bool</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;prefix&nbsp;is&nbsp;the&nbsp;entire&nbsp;regexp</span><br>
<span class="lineno">90</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">prefixRune</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="builtintype">rune</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;first&nbsp;rune&nbsp;in&nbsp;prefix</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">prefixEnd</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="builtintype">uint32</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;pc&nbsp;for&nbsp;last&nbsp;rune&nbsp;in&nbsp;prefix</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">cond</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="ident">syntax</span><span class="op">.</span><span class="ident">EmptyOp</span>&nbsp;<span class="comment">//&nbsp;empty-width&nbsp;conditions&nbsp;required&nbsp;at&nbsp;start&nbsp;of&nbsp;match</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">numSubexp</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="builtintype">int</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">subexpNames</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">string</span><br>
<span class="lineno">95</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">longest</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="builtintype">bool</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;cache&nbsp;of&nbsp;machines&nbsp;for&nbsp;running&nbsp;regexp</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">mu</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="ident">sync</span><span class="op">.</span><span class="ident">Mutex</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">machine</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="op">*</span><span class="ident">machine</span><br>
<span class="lineno">100</span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;String&nbsp;returns&nbsp;the&nbsp;source&nbsp;text&nbsp;used&nbsp;to&nbsp;compile&nbsp;the&nbsp;regular&nbsp;expression.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">String</span><span class="op">(</span><span class="op">)</span>&nbsp;<span class="builtintype">string</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">expr</span><br>
<span class="lineno">105</span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;Compile&nbsp;parses&nbsp;a&nbsp;regular&nbsp;expression&nbsp;and&nbsp;returns,&nbsp;if&nbsp;successful,</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;a&nbsp;Regexp&nbsp;object&nbsp;that&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;match&nbsp;against&nbsp;text.</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno">110</span><span class="comment">//&nbsp;When&nbsp;matching&nbsp;against&nbsp;text,&nbsp;the&nbsp;regexp&nbsp;returns&nbsp;a&nbsp;match&nbsp;that</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;begins&nbsp;as&nbsp;early&nbsp;as&nbsp;possible&nbsp;in&nbsp;the&nbsp;input&nbsp;(leftmost),&nbsp;and&nbsp;among&nbsp;those</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;it&nbsp;chooses&nbsp;the&nbsp;one&nbsp;that&nbsp;a&nbsp;backtracking&nbsp;search&nbsp;would&nbsp;have&nbsp;found&nbsp;first.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;This&nbsp;so-called&nbsp;leftmost-first&nbsp;matching&nbsp;is&nbsp;the&nbsp;same&nbsp;semantics</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;that&nbsp;Perl,&nbsp;Python,&nbsp;and&nbsp;other&nbsp;implementations&nbsp;use,&nbsp;although&nbsp;this</span><br>
<span class="lineno">115</span><span class="comment">//&nbsp;package&nbsp;implements&nbsp;it&nbsp;without&nbsp;the&nbsp;expense&nbsp;of&nbsp;backtracking.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;For&nbsp;POSIX&nbsp;leftmost-longest&nbsp;matching,&nbsp;see&nbsp;CompilePOSIX.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="ident">Compile</span><span class="op">(</span><span class="ident">expr</span>&nbsp;<span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="op">(</span><span class="op">*</span><span class="ident">Regexp</span><span class="op">,</span>&nbsp;<span class="builtintype">error</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">compile</span><span class="op">(</span><span class="ident">expr</span><span class="op">,</span>&nbsp;<span class="ident">syntax</span><span class="op">.</span><span class="ident">Perl</span><span class="op">,</span>&nbsp;<span class="ident">false</span><span class="op">)</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno">120</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;CompilePOSIX&nbsp;is&nbsp;like&nbsp;Compile&nbsp;but&nbsp;restricts&nbsp;the&nbsp;regular&nbsp;expression</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;to&nbsp;POSIX&nbsp;ERE&nbsp;(egrep)&nbsp;syntax&nbsp;and&nbsp;changes&nbsp;the&nbsp;match&nbsp;semantics&nbsp;to</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;leftmost-longest.</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno">125</span><span class="comment">//&nbsp;That&nbsp;is,&nbsp;when&nbsp;matching&nbsp;against&nbsp;text,&nbsp;the&nbsp;regexp&nbsp;returns&nbsp;a&nbsp;match&nbsp;that</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;begins&nbsp;as&nbsp;early&nbsp;as&nbsp;possible&nbsp;in&nbsp;the&nbsp;input&nbsp;(leftmost),&nbsp;and&nbsp;among&nbsp;those</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;it&nbsp;chooses&nbsp;a&nbsp;match&nbsp;that&nbsp;is&nbsp;as&nbsp;long&nbsp;as&nbsp;possible.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;This&nbsp;so-called&nbsp;leftmost-longest&nbsp;matching&nbsp;is&nbsp;the&nbsp;same&nbsp;semantics</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;that&nbsp;early&nbsp;regular&nbsp;expression&nbsp;implementations&nbsp;used&nbsp;and&nbsp;that&nbsp;POSIX</span><br>
<span class="lineno">130</span><span class="comment">//&nbsp;specifies.</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;However,&nbsp;there&nbsp;can&nbsp;be&nbsp;multiple&nbsp;leftmost-longest&nbsp;matches,&nbsp;with&nbsp;different</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;submatch&nbsp;choices,&nbsp;and&nbsp;here&nbsp;this&nbsp;package&nbsp;diverges&nbsp;from&nbsp;POSIX.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;Among&nbsp;the&nbsp;possible&nbsp;leftmost-longest&nbsp;matches,&nbsp;this&nbsp;package&nbsp;chooses</span><br>
<span class="lineno">135</span><span class="comment">//&nbsp;the&nbsp;one&nbsp;that&nbsp;a&nbsp;backtracking&nbsp;search&nbsp;would&nbsp;have&nbsp;found&nbsp;first,&nbsp;while&nbsp;POSIX</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;specifies&nbsp;that&nbsp;the&nbsp;match&nbsp;be&nbsp;chosen&nbsp;to&nbsp;maximize&nbsp;the&nbsp;length&nbsp;of&nbsp;the&nbsp;first</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;subexpression,&nbsp;then&nbsp;the&nbsp;second,&nbsp;and&nbsp;so&nbsp;on&nbsp;from&nbsp;left&nbsp;to&nbsp;right.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;The&nbsp;POSIX&nbsp;rule&nbsp;is&nbsp;computationally&nbsp;prohibitive&nbsp;and&nbsp;not&nbsp;even&nbsp;well-defined.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;See&nbsp;http://swtch.com/~rsc/regexp/regexp2.html#posix&nbsp;for&nbsp;details.</span><br>
<span class="lineno">140</span><span class="keyword">func</span>&nbsp;<span class="ident">CompilePOSIX</span><span class="op">(</span><span class="ident">expr</span>&nbsp;<span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="op">(</span><span class="op">*</span><span class="ident">Regexp</span><span class="op">,</span>&nbsp;<span class="builtintype">error</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">compile</span><span class="op">(</span><span class="ident">expr</span><span class="op">,</span>&nbsp;<span class="ident">syntax</span><span class="op">.</span><span class="ident">POSIX</span><span class="op">,</span>&nbsp;<span class="ident">true</span><span class="op">)</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;Longest&nbsp;makes&nbsp;future&nbsp;searches&nbsp;prefer&nbsp;the&nbsp;leftmost-longest&nbsp;match.</span><br>
<span class="lineno">145</span><span class="comment">//&nbsp;That&nbsp;is,&nbsp;when&nbsp;matching&nbsp;against&nbsp;text,&nbsp;the&nbsp;regexp&nbsp;returns&nbsp;a&nbsp;match&nbsp;that</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;begins&nbsp;as&nbsp;early&nbsp;as&nbsp;possible&nbsp;in&nbsp;the&nbsp;input&nbsp;(leftmost),&nbsp;and&nbsp;among&nbsp;those</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;it&nbsp;chooses&nbsp;a&nbsp;match&nbsp;that&nbsp;is&nbsp;as&nbsp;long&nbsp;as&nbsp;possible.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">Longest</span><span class="op">(</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">.</span><span class="ident">longest</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">true</span><br>
<span class="lineno">150</span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="ident">compile</span><span class="op">(</span><span class="ident">expr</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">mode</span>&nbsp;<span class="ident">syntax</span><span class="op">.</span><span class="ident">Flags</span><span class="op">,</span>&nbsp;<span class="ident">longest</span>&nbsp;<span class="builtintype">bool</span><span class="op">)</span>&nbsp;<span class="op">(</span><span class="op">*</span><span class="ident">Regexp</span><span class="op">,</span>&nbsp;<span class="builtintype">error</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">,</span>&nbsp;<span class="ident">err</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">syntax</span><span class="op">.</span><span class="ident">Parse</span><span class="op">(</span><span class="ident">expr</span><span class="op">,</span>&nbsp;<span class="ident">mode</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">err</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">155</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">err</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">maxCap</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">MaxCap</span><span class="op">(</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">capNames</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">CapNames</span><span class="op">(</span><span class="op">)</span><br>
<span class="lineno"></span><br>
<span class="lineno">160</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">Simplify</span><span class="op">(</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">prog</span><span class="op">,</span>&nbsp;<span class="ident">err</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">syntax</span><span class="op">.</span><span class="ident">Compile</span><span class="op">(</span><span class="ident">re</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">err</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">err</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">165</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">regexp</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="op">&amp;</span><span class="ident">Regexp</span><span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">expr</span><span class="op">:</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="ident">expr</span><span class="op">,</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">prog</span><span class="op">:</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="ident">prog</span><span class="op">,</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">onepass</span><span class="op">:</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="ident">compileOnePass</span><span class="op">(</span><span class="ident">prog</span><span class="op">)</span><span class="op">,</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">numSubexp</span><span class="op">:</span>&nbsp;&nbsp;&nbsp;<span class="ident">maxCap</span><span class="op">,</span><br>
<span class="lineno">170</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">subexpNames</span><span class="op">:</span>&nbsp;<span class="ident">capNames</span><span class="op">,</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">cond</span><span class="op">:</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="ident">prog</span><span class="op">.</span><span class="ident">StartCond</span><span class="op">(</span><span class="op">)</span><span class="op">,</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">longest</span><span class="op">:</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="ident">longest</span><span class="op">,</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">regexp</span><span class="op">.</span><span class="ident">onepass</span>&nbsp;<span class="op">==</span>&nbsp;<span class="ident">notOnePass</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">175</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">regexp</span><span class="op">.</span><span class="ident">prefix</span><span class="op">,</span>&nbsp;<span class="ident">regexp</span><span class="op">.</span><span class="ident">prefixComplete</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">prog</span><span class="op">.</span><span class="ident">Prefix</span><span class="op">(</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">regexp</span><span class="op">.</span><span class="ident">prefix</span><span class="op">,</span>&nbsp;<span class="ident">regexp</span><span class="op">.</span><span class="ident">prefixComplete</span><span class="op">,</span>&nbsp;<span class="ident">regexp</span><span class="op">.</span><span class="ident">prefixEnd</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">onePassPrefix</span><span class="op">(</span><span class="ident">prog</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">regexp</span><span class="op">.</span><span class="ident">prefix</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="string">&#34;&#34;</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">180</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;TODO(rsc):&nbsp;Remove&nbsp;this&nbsp;allocation&nbsp;by&nbsp;adding</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;IndexString&nbsp;to&nbsp;package&nbsp;bytes.</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">regexp</span><span class="op">.</span><span class="ident">prefixBytes</span>&nbsp;<span class="op">=</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">(</span><span class="ident">regexp</span><span class="op">.</span><span class="ident">prefix</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">regexp</span><span class="op">.</span><span class="ident">prefixRune</span><span class="op">,</span>&nbsp;<span class="ident">_</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">utf8</span><span class="op">.</span><span class="ident">DecodeRuneInString</span><span class="op">(</span><span class="ident">regexp</span><span class="op">.</span><span class="ident">prefix</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">185</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">regexp</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;get&nbsp;returns&nbsp;a&nbsp;machine&nbsp;to&nbsp;use&nbsp;for&nbsp;matching&nbsp;re.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;It&nbsp;uses&nbsp;the&nbsp;re&#39;s&nbsp;machine&nbsp;cache&nbsp;if&nbsp;possible,&nbsp;to&nbsp;avoid</span><br>
<span class="lineno">190</span><span class="comment">//&nbsp;unnecessary&nbsp;allocation.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">get</span><span class="op">(</span><span class="op">)</span>&nbsp;<span class="op">*</span><span class="ident">machine</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">.</span><span class="ident">mu</span><span class="op">.</span><span class="ident">Lock</span><span class="op">(</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">re</span><span class="op">.</span><span class="ident">machine</span><span class="op">)</span><span class="op">;</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="op">&gt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">z</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">machine</span><span class="op">[</span><span class="ident">n</span><span class="op">-</span><span class="num">1</span><span class="op">]</span><br>
<span class="lineno">195</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">.</span><span class="ident">machine</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">machine</span><span class="op">[</span><span class="op">:</span><span class="ident">n</span><span class="op">-</span><span class="num">1</span><span class="op">]</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">.</span><span class="ident">mu</span><span class="op">.</span><span class="ident">Unlock</span><span class="op">(</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">z</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">.</span><span class="ident">mu</span><span class="op">.</span><span class="ident">Unlock</span><span class="op">(</span><span class="op">)</span><br>
<span class="lineno">200</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">z</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">progMachine</span><span class="op">(</span><span class="ident">re</span><span class="op">.</span><span class="ident">prog</span><span class="op">,</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">onepass</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">z</span><span class="op">.</span><span class="ident">re</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">re</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">z</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">205</span><span class="comment">//&nbsp;put&nbsp;returns&nbsp;a&nbsp;machine&nbsp;to&nbsp;the&nbsp;re&#39;s&nbsp;machine&nbsp;cache.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;There&nbsp;is&nbsp;no&nbsp;attempt&nbsp;to&nbsp;limit&nbsp;the&nbsp;size&nbsp;of&nbsp;the&nbsp;cache,&nbsp;so&nbsp;it&nbsp;will</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;grow&nbsp;to&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;simultaneous&nbsp;matches</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;run&nbsp;using&nbsp;re.&nbsp;&nbsp;(The&nbsp;cache&nbsp;empties&nbsp;when&nbsp;re&nbsp;gets&nbsp;garbage&nbsp;collected.)</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">put</span><span class="op">(</span><span class="ident">z</span>&nbsp;<span class="op">*</span><span class="ident">machine</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">210</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">.</span><span class="ident">mu</span><span class="op">.</span><span class="ident">Lock</span><span class="op">(</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">.</span><span class="ident">machine</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">re</span><span class="op">.</span><span class="ident">machine</span><span class="op">,</span>&nbsp;<span class="ident">z</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">.</span><span class="ident">mu</span><span class="op">.</span><span class="ident">Unlock</span><span class="op">(</span><span class="op">)</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">215</span><span class="comment">//&nbsp;MustCompile&nbsp;is&nbsp;like&nbsp;Compile&nbsp;but&nbsp;panics&nbsp;if&nbsp;the&nbsp;expression&nbsp;cannot&nbsp;be&nbsp;parsed.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;It&nbsp;simplifies&nbsp;safe&nbsp;initialization&nbsp;of&nbsp;global&nbsp;variables&nbsp;holding&nbsp;compiled&nbsp;regular</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;expressions.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="ident">MustCompile</span><span class="op">(</span><span class="ident">str</span>&nbsp;<span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">regexp</span><span class="op">,</span>&nbsp;<span class="builtintype">error</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">Compile</span><span class="op">(</span><span class="ident">str</span><span class="op">)</span><br>
<span class="lineno">220</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="builtintype">error</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="builtinfunc">panic</span><span class="op">(</span><span class="string">`regexp:&nbsp;Compile(`</span>&nbsp;<span class="op">+</span>&nbsp;<span class="ident">quote</span><span class="op">(</span><span class="ident">str</span><span class="op">)</span>&nbsp;<span class="op">+</span>&nbsp;<span class="string">`):&nbsp;`</span>&nbsp;<span class="op">+</span>&nbsp;<span class="builtintype">error</span><span class="op">.</span><span class="ident">Error</span><span class="op">(</span><span class="op">)</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">regexp</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno">225</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;MustCompilePOSIX&nbsp;is&nbsp;like&nbsp;CompilePOSIX&nbsp;but&nbsp;panics&nbsp;if&nbsp;the&nbsp;expression&nbsp;cannot&nbsp;be&nbsp;parsed.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;It&nbsp;simplifies&nbsp;safe&nbsp;initialization&nbsp;of&nbsp;global&nbsp;variables&nbsp;holding&nbsp;compiled&nbsp;regular</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;expressions.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="ident">MustCompilePOSIX</span><span class="op">(</span><span class="ident">str</span>&nbsp;<span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">230</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">regexp</span><span class="op">,</span>&nbsp;<span class="builtintype">error</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">CompilePOSIX</span><span class="op">(</span><span class="ident">str</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="builtintype">error</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="builtinfunc">panic</span><span class="op">(</span><span class="string">`regexp:&nbsp;CompilePOSIX(`</span>&nbsp;<span class="op">+</span>&nbsp;<span class="ident">quote</span><span class="op">(</span><span class="ident">str</span><span class="op">)</span>&nbsp;<span class="op">+</span>&nbsp;<span class="string">`):&nbsp;`</span>&nbsp;<span class="op">+</span>&nbsp;<span class="builtintype">error</span><span class="op">.</span><span class="ident">Error</span><span class="op">(</span><span class="op">)</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">regexp</span><br>
<span class="lineno">235</span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="ident">quote</span><span class="op">(</span><span class="ident">s</span>&nbsp;<span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="builtintype">string</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">strconv</span><span class="op">.</span><span class="ident">CanBackquote</span><span class="op">(</span><span class="ident">s</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="string">&#34;`&#34;</span>&nbsp;<span class="op">+</span>&nbsp;<span class="ident">s</span>&nbsp;<span class="op">+</span>&nbsp;<span class="string">&#34;`&#34;</span><br>
<span class="lineno">240</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">strconv</span><span class="op">.</span><span class="ident">Quote</span><span class="op">(</span><span class="ident">s</span><span class="op">)</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;NumSubexp&nbsp;returns&nbsp;the&nbsp;number&nbsp;of&nbsp;parenthesized&nbsp;subexpressions&nbsp;in&nbsp;this&nbsp;Regexp.</span><br>
<span class="lineno">245</span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">NumSubexp</span><span class="op">(</span><span class="op">)</span>&nbsp;<span class="builtintype">int</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">numSubexp</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;SubexpNames&nbsp;returns&nbsp;the&nbsp;names&nbsp;of&nbsp;the&nbsp;parenthesized&nbsp;subexpressions</span><br>
<span class="lineno">250</span><span class="comment">//&nbsp;in&nbsp;this&nbsp;Regexp.&nbsp;&nbsp;The&nbsp;name&nbsp;for&nbsp;the&nbsp;first&nbsp;sub-expression&nbsp;is&nbsp;names[1],</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;so&nbsp;that&nbsp;if&nbsp;m&nbsp;is&nbsp;a&nbsp;match&nbsp;slice,&nbsp;the&nbsp;name&nbsp;for&nbsp;m[i]&nbsp;is&nbsp;SubexpNames()[i].</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;Since&nbsp;the&nbsp;Regexp&nbsp;as&nbsp;a&nbsp;whole&nbsp;cannot&nbsp;be&nbsp;named,&nbsp;names[0]&nbsp;is&nbsp;always</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;the&nbsp;empty&nbsp;string.&nbsp;&nbsp;The&nbsp;slice&nbsp;should&nbsp;not&nbsp;be&nbsp;modified.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">SubexpNames</span><span class="op">(</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">string</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">255</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">subexpNames</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">const</span>&nbsp;<span class="ident">endOfText</span>&nbsp;<span class="builtintype">rune</span>&nbsp;<span class="op">=</span>&nbsp;<span class="op">-</span><span class="num">1</span><br>
<span class="lineno"></span><br>
<span class="lineno">260</span><span class="comment">//&nbsp;input&nbsp;abstracts&nbsp;different&nbsp;representations&nbsp;of&nbsp;the&nbsp;input&nbsp;text.&nbsp;It&nbsp;provides</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;one-character&nbsp;lookahead.</span><br>
<span class="lineno"></span><span class="keyword">type</span>&nbsp;<span class="ident">input</span>&nbsp;<span class="keyword">interface</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">step</span><span class="op">(</span><span class="ident">pos</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">(</span><span class="ident">r</span>&nbsp;<span class="builtintype">rune</span><span class="op">,</span>&nbsp;<span class="ident">width</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="comment">//&nbsp;advance&nbsp;one&nbsp;rune</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">canCheckPrefix</span><span class="op">(</span><span class="op">)</span>&nbsp;<span class="builtintype">bool</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;can&nbsp;we&nbsp;look&nbsp;ahead&nbsp;without&nbsp;losing&nbsp;info?</span><br>
<span class="lineno">265</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">hasPrefix</span><span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="builtintype">bool</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">index</span><span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">,</span>&nbsp;<span class="ident">pos</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="builtintype">int</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">context</span><span class="op">(</span><span class="ident">pos</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="ident">syntax</span><span class="op">.</span><span class="ident">EmptyOp</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">270</span><span class="comment">//&nbsp;inputString&nbsp;scans&nbsp;a&nbsp;string.</span><br>
<span class="lineno"></span><span class="keyword">type</span>&nbsp;<span class="ident">inputString</span>&nbsp;<span class="keyword">struct</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">str</span>&nbsp;<span class="builtintype">string</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">275</span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">i</span>&nbsp;<span class="op">*</span><span class="ident">inputString</span><span class="op">)</span>&nbsp;<span class="ident">step</span><span class="op">(</span><span class="ident">pos</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">(</span><span class="builtintype">rune</span><span class="op">,</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">pos</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">c</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">[</span><span class="ident">pos</span><span class="op">]</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">c</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="ident">utf8</span><span class="op">.</span><span class="ident">RuneSelf</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="builtintype">rune</span><span class="op">(</span><span class="ident">c</span><span class="op">)</span><span class="op">,</span>&nbsp;<span class="num">1</span><br>
<span class="lineno">280</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">utf8</span><span class="op">.</span><span class="ident">DecodeRuneInString</span><span class="op">(</span><span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">[</span><span class="ident">pos</span><span class="op">:</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">endOfText</span><span class="op">,</span>&nbsp;<span class="num">0</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno">285</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">i</span>&nbsp;<span class="op">*</span><span class="ident">inputString</span><span class="op">)</span>&nbsp;<span class="ident">canCheckPrefix</span><span class="op">(</span><span class="op">)</span>&nbsp;<span class="builtintype">bool</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">true</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">290</span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">i</span>&nbsp;<span class="op">*</span><span class="ident">inputString</span><span class="op">)</span>&nbsp;<span class="ident">hasPrefix</span><span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="builtintype">bool</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">strings</span><span class="op">.</span><span class="ident">HasPrefix</span><span class="op">(</span><span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">,</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">prefix</span><span class="op">)</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">i</span>&nbsp;<span class="op">*</span><span class="ident">inputString</span><span class="op">)</span>&nbsp;<span class="ident">index</span><span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">,</span>&nbsp;<span class="ident">pos</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="builtintype">int</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">295</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">strings</span><span class="op">.</span><span class="ident">Index</span><span class="op">(</span><span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">[</span><span class="ident">pos</span><span class="op">:</span><span class="op">]</span><span class="op">,</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">prefix</span><span class="op">)</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">i</span>&nbsp;<span class="op">*</span><span class="ident">inputString</span><span class="op">)</span>&nbsp;<span class="ident">context</span><span class="op">(</span><span class="ident">pos</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="ident">syntax</span><span class="op">.</span><span class="ident">EmptyOp</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">r1</span><span class="op">,</span>&nbsp;<span class="ident">r2</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">endOfText</span><span class="op">,</span>&nbsp;<span class="ident">endOfText</span><br>
<span class="lineno">300</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">pos</span>&nbsp;<span class="op">&gt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">&amp;&amp;</span>&nbsp;<span class="ident">pos</span>&nbsp;<span class="op">&lt;=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">r1</span><span class="op">,</span>&nbsp;<span class="ident">_</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">utf8</span><span class="op">.</span><span class="ident">DecodeLastRuneInString</span><span class="op">(</span><span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">[</span><span class="op">:</span><span class="ident">pos</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">pos</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">r2</span><span class="op">,</span>&nbsp;<span class="ident">_</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">utf8</span><span class="op">.</span><span class="ident">DecodeRuneInString</span><span class="op">(</span><span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">[</span><span class="ident">pos</span><span class="op">:</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno">305</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">syntax</span><span class="op">.</span><span class="ident">EmptyOpContext</span><span class="op">(</span><span class="ident">r1</span><span class="op">,</span>&nbsp;<span class="ident">r2</span><span class="op">)</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;inputBytes&nbsp;scans&nbsp;a&nbsp;byte&nbsp;slice.</span><br>
<span class="lineno">310</span><span class="keyword">type</span>&nbsp;<span class="ident">inputBytes</span>&nbsp;<span class="keyword">struct</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">str</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">i</span>&nbsp;<span class="op">*</span><span class="ident">inputBytes</span><span class="op">)</span>&nbsp;<span class="ident">step</span><span class="op">(</span><span class="ident">pos</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">(</span><span class="builtintype">rune</span><span class="op">,</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">315</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">pos</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">c</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">[</span><span class="ident">pos</span><span class="op">]</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">c</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="ident">utf8</span><span class="op">.</span><span class="ident">RuneSelf</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="builtintype">rune</span><span class="op">(</span><span class="ident">c</span><span class="op">)</span><span class="op">,</span>&nbsp;<span class="num">1</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">320</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">utf8</span><span class="op">.</span><span class="ident">DecodeRune</span><span class="op">(</span><span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">[</span><span class="ident">pos</span><span class="op">:</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">endOfText</span><span class="op">,</span>&nbsp;<span class="num">0</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">325</span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">i</span>&nbsp;<span class="op">*</span><span class="ident">inputBytes</span><span class="op">)</span>&nbsp;<span class="ident">canCheckPrefix</span><span class="op">(</span><span class="op">)</span>&nbsp;<span class="builtintype">bool</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">true</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">i</span>&nbsp;<span class="op">*</span><span class="ident">inputBytes</span><span class="op">)</span>&nbsp;<span class="ident">hasPrefix</span><span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="builtintype">bool</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">330</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">bytes</span><span class="op">.</span><span class="ident">HasPrefix</span><span class="op">(</span><span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">,</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">prefixBytes</span><span class="op">)</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">i</span>&nbsp;<span class="op">*</span><span class="ident">inputBytes</span><span class="op">)</span>&nbsp;<span class="ident">index</span><span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">,</span>&nbsp;<span class="ident">pos</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="builtintype">int</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">bytes</span><span class="op">.</span><span class="ident">Index</span><span class="op">(</span><span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">[</span><span class="ident">pos</span><span class="op">:</span><span class="op">]</span><span class="op">,</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">prefixBytes</span><span class="op">)</span><br>
<span class="lineno">335</span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">i</span>&nbsp;<span class="op">*</span><span class="ident">inputBytes</span><span class="op">)</span>&nbsp;<span class="ident">context</span><span class="op">(</span><span class="ident">pos</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="ident">syntax</span><span class="op">.</span><span class="ident">EmptyOp</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">r1</span><span class="op">,</span>&nbsp;<span class="ident">r2</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">endOfText</span><span class="op">,</span>&nbsp;<span class="ident">endOfText</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">pos</span>&nbsp;<span class="op">&gt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">&amp;&amp;</span>&nbsp;<span class="ident">pos</span>&nbsp;<span class="op">&lt;=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">340</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">r1</span><span class="op">,</span>&nbsp;<span class="ident">_</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">utf8</span><span class="op">.</span><span class="ident">DecodeLastRune</span><span class="op">(</span><span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">[</span><span class="op">:</span><span class="ident">pos</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">pos</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">r2</span><span class="op">,</span>&nbsp;<span class="ident">_</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">utf8</span><span class="op">.</span><span class="ident">DecodeRune</span><span class="op">(</span><span class="ident">i</span><span class="op">.</span><span class="ident">str</span><span class="op">[</span><span class="ident">pos</span><span class="op">:</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">345</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">syntax</span><span class="op">.</span><span class="ident">EmptyOpContext</span><span class="op">(</span><span class="ident">r1</span><span class="op">,</span>&nbsp;<span class="ident">r2</span><span class="op">)</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;inputReader&nbsp;scans&nbsp;a&nbsp;RuneReader.</span><br>
<span class="lineno"></span><span class="keyword">type</span>&nbsp;<span class="ident">inputReader</span>&nbsp;<span class="keyword">struct</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">350</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">r</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="ident">io</span><span class="op">.</span><span class="ident">RuneReader</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">atEOT</span>&nbsp;<span class="builtintype">bool</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">pos</span>&nbsp;&nbsp;&nbsp;<span class="builtintype">int</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">355</span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">i</span>&nbsp;<span class="op">*</span><span class="ident">inputReader</span><span class="op">)</span>&nbsp;<span class="ident">step</span><span class="op">(</span><span class="ident">pos</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">(</span><span class="builtintype">rune</span><span class="op">,</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="op">!</span><span class="ident">i</span><span class="op">.</span><span class="ident">atEOT</span>&nbsp;<span class="op">&amp;&amp;</span>&nbsp;<span class="ident">pos</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">i</span><span class="op">.</span><span class="ident">pos</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">endOfText</span><span class="op">,</span>&nbsp;<span class="num">0</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">360</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">r</span><span class="op">,</span>&nbsp;<span class="ident">w</span><span class="op">,</span>&nbsp;<span class="ident">err</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">i</span><span class="op">.</span><span class="ident">r</span><span class="op">.</span><span class="ident">ReadRune</span><span class="op">(</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">err</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">i</span><span class="op">.</span><span class="ident">atEOT</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">true</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">endOfText</span><span class="op">,</span>&nbsp;<span class="num">0</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">365</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">i</span><span class="op">.</span><span class="ident">pos</span>&nbsp;<span class="op">+=</span>&nbsp;<span class="ident">w</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">r</span><span class="op">,</span>&nbsp;<span class="ident">w</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">i</span>&nbsp;<span class="op">*</span><span class="ident">inputReader</span><span class="op">)</span>&nbsp;<span class="ident">canCheckPrefix</span><span class="op">(</span><span class="op">)</span>&nbsp;<span class="builtintype">bool</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">370</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">false</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">i</span>&nbsp;<span class="op">*</span><span class="ident">inputReader</span><span class="op">)</span>&nbsp;<span class="ident">hasPrefix</span><span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="builtintype">bool</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">false</span><br>
<span class="lineno">375</span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">i</span>&nbsp;<span class="op">*</span><span class="ident">inputReader</span><span class="op">)</span>&nbsp;<span class="ident">index</span><span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">,</span>&nbsp;<span class="ident">pos</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="builtintype">int</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="op">-</span><span class="num">1</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno">380</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">i</span>&nbsp;<span class="op">*</span><span class="ident">inputReader</span><span class="op">)</span>&nbsp;<span class="ident">context</span><span class="op">(</span><span class="ident">pos</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="ident">syntax</span><span class="op">.</span><span class="ident">EmptyOp</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="num">0</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">385</span><span class="comment">//&nbsp;LiteralPrefix&nbsp;returns&nbsp;a&nbsp;literal&nbsp;string&nbsp;that&nbsp;must&nbsp;begin&nbsp;any&nbsp;match</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;of&nbsp;the&nbsp;regular&nbsp;expression&nbsp;re.&nbsp;&nbsp;It&nbsp;returns&nbsp;the&nbsp;boolean&nbsp;true&nbsp;if&nbsp;the</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;literal&nbsp;string&nbsp;comprises&nbsp;the&nbsp;entire&nbsp;regular&nbsp;expression.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">LiteralPrefix</span><span class="op">(</span><span class="op">)</span>&nbsp;<span class="op">(</span><span class="ident">prefix</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">complete</span>&nbsp;<span class="builtintype">bool</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">prefix</span><span class="op">,</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">prefixComplete</span><br>
<span class="lineno">390</span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;MatchReader&nbsp;reports&nbsp;whether&nbsp;the&nbsp;Regexp&nbsp;matches&nbsp;the&nbsp;text&nbsp;read&nbsp;by&nbsp;the</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;RuneReader.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">MatchReader</span><span class="op">(</span><span class="ident">r</span>&nbsp;<span class="ident">io</span><span class="op">.</span><span class="ident">RuneReader</span><span class="op">)</span>&nbsp;<span class="builtintype">bool</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">395</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">doExecute</span><span class="op">(</span><span class="ident">r</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">)</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;MatchString&nbsp;reports&nbsp;whether&nbsp;the&nbsp;Regexp&nbsp;matches&nbsp;the&nbsp;string&nbsp;s.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">MatchString</span><span class="op">(</span><span class="ident">s</span>&nbsp;<span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="builtintype">bool</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">400</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">doExecute</span><span class="op">(</span><span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">s</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">)</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;Match&nbsp;reports&nbsp;whether&nbsp;the&nbsp;Regexp&nbsp;matches&nbsp;the&nbsp;byte&nbsp;slice&nbsp;b.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">Match</span><span class="op">(</span><span class="ident">b</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">)</span>&nbsp;<span class="builtintype">bool</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">405</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">doExecute</span><span class="op">(</span><span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">b</span><span class="op">,</span>&nbsp;<span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">)</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;MatchReader&nbsp;checks&nbsp;whether&nbsp;a&nbsp;textual&nbsp;regular&nbsp;expression&nbsp;matches&nbsp;the&nbsp;text</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;read&nbsp;by&nbsp;the&nbsp;RuneReader.&nbsp;&nbsp;More&nbsp;complicated&nbsp;queries&nbsp;need&nbsp;to&nbsp;use&nbsp;Compile&nbsp;and</span><br>
<span class="lineno">410</span><span class="comment">//&nbsp;the&nbsp;full&nbsp;Regexp&nbsp;interface.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="ident">MatchReader</span><span class="op">(</span><span class="ident">pattern</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">r</span>&nbsp;<span class="ident">io</span><span class="op">.</span><span class="ident">RuneReader</span><span class="op">)</span>&nbsp;<span class="op">(</span><span class="ident">matched</span>&nbsp;<span class="builtintype">bool</span><span class="op">,</span>&nbsp;<span class="ident">err</span>&nbsp;<span class="builtintype">error</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">,</span>&nbsp;<span class="ident">err</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">Compile</span><span class="op">(</span><span class="ident">pattern</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">err</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">false</span><span class="op">,</span>&nbsp;<span class="ident">err</span><br>
<span class="lineno">415</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">MatchReader</span><span class="op">(</span><span class="ident">r</span><span class="op">)</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;MatchString&nbsp;checks&nbsp;whether&nbsp;a&nbsp;textual&nbsp;regular&nbsp;expression</span><br>
<span class="lineno">420</span><span class="comment">//&nbsp;matches&nbsp;a&nbsp;string.&nbsp;&nbsp;More&nbsp;complicated&nbsp;queries&nbsp;need</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;to&nbsp;use&nbsp;Compile&nbsp;and&nbsp;the&nbsp;full&nbsp;Regexp&nbsp;interface.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="ident">MatchString</span><span class="op">(</span><span class="ident">pattern</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">s</span>&nbsp;<span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="op">(</span><span class="ident">matched</span>&nbsp;<span class="builtintype">bool</span><span class="op">,</span>&nbsp;<span class="ident">err</span>&nbsp;<span class="builtintype">error</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">,</span>&nbsp;<span class="ident">err</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">Compile</span><span class="op">(</span><span class="ident">pattern</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">err</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">425</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">false</span><span class="op">,</span>&nbsp;<span class="ident">err</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">MatchString</span><span class="op">(</span><span class="ident">s</span><span class="op">)</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">430</span><span class="comment">//&nbsp;Match&nbsp;checks&nbsp;whether&nbsp;a&nbsp;textual&nbsp;regular&nbsp;expression</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;matches&nbsp;a&nbsp;byte&nbsp;slice.&nbsp;&nbsp;More&nbsp;complicated&nbsp;queries&nbsp;need</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;to&nbsp;use&nbsp;Compile&nbsp;and&nbsp;the&nbsp;full&nbsp;Regexp&nbsp;interface.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="ident">Match</span><span class="op">(</span><span class="ident">pattern</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">b</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">)</span>&nbsp;<span class="op">(</span><span class="ident">matched</span>&nbsp;<span class="builtintype">bool</span><span class="op">,</span>&nbsp;<span class="ident">err</span>&nbsp;<span class="builtintype">error</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">,</span>&nbsp;<span class="ident">err</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">Compile</span><span class="op">(</span><span class="ident">pattern</span><span class="op">)</span><br>
<span class="lineno">435</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">err</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">false</span><span class="op">,</span>&nbsp;<span class="ident">err</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">Match</span><span class="op">(</span><span class="ident">b</span><span class="op">)</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno">440</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;ReplaceAllString&nbsp;returns&nbsp;a&nbsp;copy&nbsp;of&nbsp;src,&nbsp;replacing&nbsp;matches&nbsp;of&nbsp;the&nbsp;Regexp</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;with&nbsp;the&nbsp;replacement&nbsp;string&nbsp;repl.&nbsp;&nbsp;Inside&nbsp;repl,&nbsp;$&nbsp;signs&nbsp;are&nbsp;interpreted&nbsp;as</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;in&nbsp;Expand,&nbsp;so&nbsp;for&nbsp;instance&nbsp;$1&nbsp;represents&nbsp;the&nbsp;text&nbsp;of&nbsp;the&nbsp;first&nbsp;submatch.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">ReplaceAllString</span><span class="op">(</span><span class="ident">src</span><span class="op">,</span>&nbsp;<span class="ident">repl</span>&nbsp;<span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="builtintype">string</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">445</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">n</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="num">2</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">strings</span><span class="op">.</span><span class="ident">Index</span><span class="op">(</span><span class="ident">repl</span><span class="op">,</span>&nbsp;<span class="string">&#34;$&#34;</span><span class="op">)</span>&nbsp;<span class="op">&gt;=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">n</span>&nbsp;<span class="op">=</span>&nbsp;<span class="num">2</span>&nbsp;<span class="op">*</span>&nbsp;<span class="op">(</span><span class="ident">re</span><span class="op">.</span><span class="ident">numSubexp</span>&nbsp;<span class="op">+</span>&nbsp;<span class="num">1</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">b</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">replaceAll</span><span class="op">(</span><span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">src</span><span class="op">,</span>&nbsp;<span class="ident">n</span><span class="op">,</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="ident">dst</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">450</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">expand</span><span class="op">(</span><span class="ident">dst</span><span class="op">,</span>&nbsp;<span class="ident">repl</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">src</span><span class="op">,</span>&nbsp;<span class="ident">match</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="builtintype">string</span><span class="op">(</span><span class="ident">b</span><span class="op">)</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">455</span><span class="comment">//&nbsp;ReplaceAllLiteralString&nbsp;returns&nbsp;a&nbsp;copy&nbsp;of&nbsp;src,&nbsp;replacing&nbsp;matches&nbsp;of&nbsp;the&nbsp;Regexp</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;with&nbsp;the&nbsp;replacement&nbsp;string&nbsp;repl.&nbsp;&nbsp;The&nbsp;replacement&nbsp;repl&nbsp;is&nbsp;substituted&nbsp;directly,</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;without&nbsp;using&nbsp;Expand.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">ReplaceAllLiteralString</span><span class="op">(</span><span class="ident">src</span><span class="op">,</span>&nbsp;<span class="ident">repl</span>&nbsp;<span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="builtintype">string</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="builtintype">string</span><span class="op">(</span><span class="ident">re</span><span class="op">.</span><span class="ident">replaceAll</span><span class="op">(</span><span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">src</span><span class="op">,</span>&nbsp;<span class="num">2</span><span class="op">,</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="ident">dst</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">460</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">dst</span><span class="op">,</span>&nbsp;<span class="ident">repl</span><span class="op">...</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><span class="op">)</span><span class="op">)</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;ReplaceAllStringFunc&nbsp;returns&nbsp;a&nbsp;copy&nbsp;of&nbsp;src&nbsp;in&nbsp;which&nbsp;all&nbsp;matches&nbsp;of&nbsp;the</span><br>
<span class="lineno">465</span><span class="comment">//&nbsp;Regexp&nbsp;have&nbsp;been&nbsp;replaced&nbsp;by&nbsp;the&nbsp;return&nbsp;value&nbsp;of&nbsp;function&nbsp;repl&nbsp;applied</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;to&nbsp;the&nbsp;matched&nbsp;substring.&nbsp;&nbsp;The&nbsp;replacement&nbsp;returned&nbsp;by&nbsp;repl&nbsp;is&nbsp;substituted</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;directly,&nbsp;without&nbsp;using&nbsp;Expand.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">ReplaceAllStringFunc</span><span class="op">(</span><span class="ident">src</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">repl</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="builtintype">string</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">b</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">replaceAll</span><span class="op">(</span><span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">src</span><span class="op">,</span>&nbsp;<span class="num">2</span><span class="op">,</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="ident">dst</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">470</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">dst</span><span class="op">,</span>&nbsp;<span class="ident">repl</span><span class="op">(</span><span class="ident">src</span><span class="op">[</span><span class="ident">match</span><span class="op">[</span><span class="num">0</span><span class="op">]</span><span class="op">:</span><span class="ident">match</span><span class="op">[</span><span class="num">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op">...</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="builtintype">string</span><span class="op">(</span><span class="ident">b</span><span class="op">)</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">475</span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">replaceAll</span><span class="op">(</span><span class="ident">bsrc</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">src</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">nmatch</span>&nbsp;<span class="builtintype">int</span><span class="op">,</span>&nbsp;<span class="ident">repl</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="ident">dst</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">m</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">lastMatchEnd</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="comment">//&nbsp;end&nbsp;position&nbsp;of&nbsp;the&nbsp;most&nbsp;recent&nbsp;match</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">searchPos</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="num">0</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;position&nbsp;where&nbsp;we&nbsp;next&nbsp;look&nbsp;for&nbsp;a&nbsp;match</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">var</span>&nbsp;<span class="ident">buf</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">var</span>&nbsp;<span class="ident">endPos</span>&nbsp;<span class="builtintype">int</span><br>
<span class="lineno">480</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">bsrc</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">endPos</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">bsrc</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">endPos</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">src</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">485</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">for</span>&nbsp;<span class="ident">searchPos</span>&nbsp;<span class="op">&lt;=</span>&nbsp;<span class="ident">endPos</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">a</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">doExecute</span><span class="op">(</span><span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">bsrc</span><span class="op">,</span>&nbsp;<span class="ident">src</span><span class="op">,</span>&nbsp;<span class="ident">searchPos</span><span class="op">,</span>&nbsp;<span class="ident">nmatch</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">a</span><span class="op">)</span>&nbsp;<span class="op">==</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">break</span>&nbsp;<span class="comment">//&nbsp;no&nbsp;more&nbsp;matches</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">490</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;Copy&nbsp;the&nbsp;unmatched&nbsp;characters&nbsp;before&nbsp;this&nbsp;match.</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">bsrc</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">buf</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">buf</span><span class="op">,</span>&nbsp;<span class="ident">bsrc</span><span class="op">[</span><span class="ident">lastMatchEnd</span><span class="op">:</span><span class="ident">a</span><span class="op">[</span><span class="num">0</span><span class="op">]</span><span class="op">]</span><span class="op">...</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">495</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">buf</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">buf</span><span class="op">,</span>&nbsp;<span class="ident">src</span><span class="op">[</span><span class="ident">lastMatchEnd</span><span class="op">:</span><span class="ident">a</span><span class="op">[</span><span class="num">0</span><span class="op">]</span><span class="op">]</span><span class="op">...</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;Now&nbsp;insert&nbsp;a&nbsp;copy&nbsp;of&nbsp;the&nbsp;replacement&nbsp;string,&nbsp;but&nbsp;not&nbsp;for&nbsp;a</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;match&nbsp;of&nbsp;the&nbsp;empty&nbsp;string&nbsp;immediately&nbsp;after&nbsp;another&nbsp;match.</span><br>
<span class="lineno">500</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;(Otherwise,&nbsp;we&nbsp;get&nbsp;double&nbsp;replacement&nbsp;for&nbsp;patterns&nbsp;that</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;match&nbsp;both&nbsp;empty&nbsp;and&nbsp;nonempty&nbsp;strings.)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">a</span><span class="op">[</span><span class="num">1</span><span class="op">]</span>&nbsp;<span class="op">&gt;</span>&nbsp;<span class="ident">lastMatchEnd</span>&nbsp;<span class="op">||</span>&nbsp;<span class="ident">a</span><span class="op">[</span><span class="num">0</span><span class="op">]</span>&nbsp;<span class="op">==</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">buf</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">repl</span><span class="op">(</span><span class="ident">buf</span><span class="op">,</span>&nbsp;<span class="ident">a</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">505</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">lastMatchEnd</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">a</span><span class="op">[</span><span class="num">1</span><span class="op">]</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;Advance&nbsp;past&nbsp;this&nbsp;match;&nbsp;always&nbsp;advance&nbsp;at&nbsp;least&nbsp;one&nbsp;character.</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">var</span>&nbsp;<span class="ident">width</span>&nbsp;<span class="builtintype">int</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">bsrc</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">510</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">_</span><span class="op">,</span>&nbsp;<span class="ident">width</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">utf8</span><span class="op">.</span><span class="ident">DecodeRune</span><span class="op">(</span><span class="ident">bsrc</span><span class="op">[</span><span class="ident">searchPos</span><span class="op">:</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">_</span><span class="op">,</span>&nbsp;<span class="ident">width</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">utf8</span><span class="op">.</span><span class="ident">DecodeRuneInString</span><span class="op">(</span><span class="ident">src</span><span class="op">[</span><span class="ident">searchPos</span><span class="op">:</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">searchPos</span><span class="op">+</span><span class="ident">width</span>&nbsp;<span class="op">&gt;</span>&nbsp;<span class="ident">a</span><span class="op">[</span><span class="num">1</span><span class="op">]</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">515</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">searchPos</span>&nbsp;<span class="op">+=</span>&nbsp;<span class="ident">width</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="keyword">if</span>&nbsp;<span class="ident">searchPos</span><span class="op">+</span><span class="num">1</span>&nbsp;<span class="op">&gt;</span>&nbsp;<span class="ident">a</span><span class="op">[</span><span class="num">1</span><span class="op">]</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;This&nbsp;clause&nbsp;is&nbsp;only&nbsp;needed&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;input</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;string.&nbsp;&nbsp;In&nbsp;that&nbsp;case,&nbsp;DecodeRuneInString&nbsp;returns&nbsp;width=0.</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">searchPos</span><span class="op">++</span><br>
<span class="lineno">520</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">searchPos</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">a</span><span class="op">[</span><span class="num">1</span><span class="op">]</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">525</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;Copy&nbsp;the&nbsp;unmatched&nbsp;characters&nbsp;after&nbsp;the&nbsp;last&nbsp;match.</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">bsrc</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">buf</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">buf</span><span class="op">,</span>&nbsp;<span class="ident">bsrc</span><span class="op">[</span><span class="ident">lastMatchEnd</span><span class="op">:</span><span class="op">]</span><span class="op">...</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">buf</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">buf</span><span class="op">,</span>&nbsp;<span class="ident">src</span><span class="op">[</span><span class="ident">lastMatchEnd</span><span class="op">:</span><span class="op">]</span><span class="op">...</span><span class="op">)</span><br>
<span class="lineno">530</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">buf</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">535</span><span class="comment">//&nbsp;ReplaceAll&nbsp;returns&nbsp;a&nbsp;copy&nbsp;of&nbsp;src,&nbsp;replacing&nbsp;matches&nbsp;of&nbsp;the&nbsp;Regexp</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;with&nbsp;the&nbsp;replacement&nbsp;text&nbsp;repl.&nbsp;&nbsp;Inside&nbsp;repl,&nbsp;$&nbsp;signs&nbsp;are&nbsp;interpreted&nbsp;as</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;in&nbsp;Expand,&nbsp;so&nbsp;for&nbsp;instance&nbsp;$1&nbsp;represents&nbsp;the&nbsp;text&nbsp;of&nbsp;the&nbsp;first&nbsp;submatch.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">ReplaceAll</span><span class="op">(</span><span class="ident">src</span><span class="op">,</span>&nbsp;<span class="ident">repl</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">n</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="num">2</span><br>
<span class="lineno">540</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">bytes</span><span class="op">.</span><span class="ident">IndexByte</span><span class="op">(</span><span class="ident">repl</span><span class="op">,</span>&nbsp;<span class="string">&#39;$&#39;</span><span class="op">)</span>&nbsp;<span class="op">&gt;=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">n</span>&nbsp;<span class="op">=</span>&nbsp;<span class="num">2</span>&nbsp;<span class="op">*</span>&nbsp;<span class="op">(</span><span class="ident">re</span><span class="op">.</span><span class="ident">numSubexp</span>&nbsp;<span class="op">+</span>&nbsp;<span class="num">1</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">srepl</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="string">&#34;&#34;</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">b</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">replaceAll</span><span class="op">(</span><span class="ident">src</span><span class="op">,</span>&nbsp;<span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="ident">n</span><span class="op">,</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="ident">dst</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">545</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">srepl</span><span class="op">)</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">repl</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">srepl</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtintype">string</span><span class="op">(</span><span class="ident">repl</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">expand</span><span class="op">(</span><span class="ident">dst</span><span class="op">,</span>&nbsp;<span class="ident">srepl</span><span class="op">,</span>&nbsp;<span class="ident">src</span><span class="op">,</span>&nbsp;<span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="ident">match</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><span class="op">)</span><br>
<span class="lineno">550</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">b</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;ReplaceAllLiteral&nbsp;returns&nbsp;a&nbsp;copy&nbsp;of&nbsp;src,&nbsp;replacing&nbsp;matches&nbsp;of&nbsp;the&nbsp;Regexp</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;with&nbsp;the&nbsp;replacement&nbsp;bytes&nbsp;repl.&nbsp;&nbsp;The&nbsp;replacement&nbsp;repl&nbsp;is&nbsp;substituted&nbsp;directly,</span><br>
<span class="lineno">555</span><span class="comment">//&nbsp;without&nbsp;using&nbsp;Expand.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">ReplaceAllLiteral</span><span class="op">(</span><span class="ident">src</span><span class="op">,</span>&nbsp;<span class="ident">repl</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">replaceAll</span><span class="op">(</span><span class="ident">src</span><span class="op">,</span>&nbsp;<span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="num">2</span><span class="op">,</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="ident">dst</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">dst</span><span class="op">,</span>&nbsp;<span class="ident">repl</span><span class="op">...</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><span class="op">)</span><br>
<span class="lineno">560</span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;ReplaceAllFunc&nbsp;returns&nbsp;a&nbsp;copy&nbsp;of&nbsp;src&nbsp;in&nbsp;which&nbsp;all&nbsp;matches&nbsp;of&nbsp;the</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;Regexp&nbsp;have&nbsp;been&nbsp;replaced&nbsp;by&nbsp;the&nbsp;return&nbsp;value&nbsp;of&nbsp;function&nbsp;repl&nbsp;applied</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;to&nbsp;the&nbsp;matched&nbsp;byte&nbsp;slice.&nbsp;&nbsp;The&nbsp;replacement&nbsp;returned&nbsp;by&nbsp;repl&nbsp;is&nbsp;substituted</span><br>
<span class="lineno">565</span><span class="comment">//&nbsp;directly,&nbsp;without&nbsp;using&nbsp;Expand.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">ReplaceAllFunc</span><span class="op">(</span><span class="ident">src</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">repl</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">replaceAll</span><span class="op">(</span><span class="ident">src</span><span class="op">,</span>&nbsp;<span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="num">2</span><span class="op">,</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="ident">dst</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">dst</span><span class="op">,</span>&nbsp;<span class="ident">repl</span><span class="op">(</span><span class="ident">src</span><span class="op">[</span><span class="ident">match</span><span class="op">[</span><span class="num">0</span><span class="op">]</span><span class="op">:</span><span class="ident">match</span><span class="op">[</span><span class="num">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op">...</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><span class="op">)</span><br>
<span class="lineno">570</span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">var</span>&nbsp;<span class="ident">specialBytes</span>&nbsp;<span class="op">=</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">(</span><span class="string">`\.+*?()|[]{}^$`</span><span class="op">)</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="ident">special</span><span class="op">(</span><span class="ident">b</span>&nbsp;<span class="builtintype">byte</span><span class="op">)</span>&nbsp;<span class="builtintype">bool</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">575</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">bytes</span><span class="op">.</span><span class="ident">IndexByte</span><span class="op">(</span><span class="ident">specialBytes</span><span class="op">,</span>&nbsp;<span class="ident">b</span><span class="op">)</span>&nbsp;<span class="op">&gt;=</span>&nbsp;<span class="num">0</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;QuoteMeta&nbsp;returns&nbsp;a&nbsp;string&nbsp;that&nbsp;quotes&nbsp;all&nbsp;regular&nbsp;expression&nbsp;metacharacters</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;inside&nbsp;the&nbsp;argument&nbsp;text;&nbsp;the&nbsp;returned&nbsp;string&nbsp;is&nbsp;a&nbsp;regular&nbsp;expression&nbsp;matching</span><br>
<span class="lineno">580</span><span class="comment">//&nbsp;the&nbsp;literal&nbsp;text.&nbsp;&nbsp;For&nbsp;example,&nbsp;QuoteMeta(`[foo]`)&nbsp;returns&nbsp;`\[foo\]`.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="ident">QuoteMeta</span><span class="op">(</span><span class="ident">s</span>&nbsp;<span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="builtintype">string</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">b</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="builtinfunc">make</span><span class="op">(</span><span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="num">2</span><span class="op">*</span><span class="builtinfunc">len</span><span class="op">(</span><span class="ident">s</span><span class="op">)</span><span class="op">)</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;A&nbsp;byte&nbsp;loop&nbsp;is&nbsp;correct&nbsp;because&nbsp;all&nbsp;metacharacters&nbsp;are&nbsp;ASCII.</span><br>
<span class="lineno">585</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">j</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="num">0</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">for</span>&nbsp;<span class="ident">i</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="num">0</span><span class="op">;</span>&nbsp;<span class="ident">i</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">s</span><span class="op">)</span><span class="op">;</span>&nbsp;<span class="ident">i</span><span class="op">++</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">special</span><span class="op">(</span><span class="ident">s</span><span class="op">[</span><span class="ident">i</span><span class="op">]</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">b</span><span class="op">[</span><span class="ident">j</span><span class="op">]</span>&nbsp;<span class="op">=</span>&nbsp;<span class="string">&#39;\\&#39;</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">j</span><span class="op">++</span><br>
<span class="lineno">590</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">b</span><span class="op">[</span><span class="ident">j</span><span class="op">]</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">s</span><span class="op">[</span><span class="ident">i</span><span class="op">]</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">j</span><span class="op">++</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="builtintype">string</span><span class="op">(</span><span class="ident">b</span><span class="op">[</span><span class="num">0</span><span class="op">:</span><span class="ident">j</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno">595</span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;The&nbsp;number&nbsp;of&nbsp;capture&nbsp;values&nbsp;in&nbsp;the&nbsp;program&nbsp;may&nbsp;correspond</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;to&nbsp;fewer&nbsp;capturing&nbsp;expressions&nbsp;than&nbsp;are&nbsp;in&nbsp;the&nbsp;regexp.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;For&nbsp;example,&nbsp;&#34;(a){0}&#34;&nbsp;turns&nbsp;into&nbsp;an&nbsp;empty&nbsp;program,&nbsp;so&nbsp;the</span><br>
<span class="lineno">600</span><span class="comment">//&nbsp;maximum&nbsp;capture&nbsp;in&nbsp;the&nbsp;program&nbsp;is&nbsp;0&nbsp;but&nbsp;we&nbsp;need&nbsp;to&nbsp;return</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;an&nbsp;expression&nbsp;for&nbsp;\1.&nbsp;&nbsp;Pad&nbsp;appends&nbsp;-1s&nbsp;to&nbsp;the&nbsp;slice&nbsp;a&nbsp;as&nbsp;needed.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">pad</span><span class="op">(</span><span class="ident">a</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">a</span>&nbsp;<span class="op">==</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;No&nbsp;match.</span><br>
<span class="lineno">605</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">n</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="op">(</span><span class="num">1</span>&nbsp;<span class="op">+</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">numSubexp</span><span class="op">)</span>&nbsp;<span class="op">*</span>&nbsp;<span class="num">2</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">for</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">a</span><span class="op">)</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">a</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">a</span><span class="op">,</span>&nbsp;<span class="op">-</span><span class="num">1</span><span class="op">)</span><br>
<span class="lineno">610</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">a</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;Find&nbsp;matches&nbsp;in&nbsp;slice&nbsp;b&nbsp;if&nbsp;b&nbsp;is&nbsp;non-nil,&nbsp;otherwise&nbsp;find&nbsp;matches&nbsp;in&nbsp;string&nbsp;s.</span><br>
<span class="lineno">615</span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">allMatches</span><span class="op">(</span><span class="ident">s</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">b</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="builtintype">int</span><span class="op">,</span>&nbsp;<span class="ident">deliver</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">var</span>&nbsp;<span class="ident">end</span>&nbsp;<span class="builtintype">int</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">b</span>&nbsp;<span class="op">==</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">end</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">s</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">620</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">end</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">b</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">for</span>&nbsp;<span class="ident">pos</span><span class="op">,</span>&nbsp;<span class="ident">i</span><span class="op">,</span>&nbsp;<span class="ident">prevMatchEnd</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="op">-</span><span class="num">1</span><span class="op">;</span>&nbsp;<span class="ident">i</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="op">&amp;&amp;</span>&nbsp;<span class="ident">pos</span>&nbsp;<span class="op">&lt;=</span>&nbsp;<span class="ident">end</span><span class="op">;</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">matches</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">doExecute</span><span class="op">(</span><span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">b</span><span class="op">,</span>&nbsp;<span class="ident">s</span><span class="op">,</span>&nbsp;<span class="ident">pos</span><span class="op">,</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">prog</span><span class="op">.</span><span class="ident">NumCap</span><span class="op">)</span><br>
<span class="lineno">625</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">matches</span><span class="op">)</span>&nbsp;<span class="op">==</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">break</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">accept</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">true</span><br>
<span class="lineno">630</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">matches</span><span class="op">[</span><span class="num">1</span><span class="op">]</span>&nbsp;<span class="op">==</span>&nbsp;<span class="ident">pos</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;We&#39;ve&nbsp;found&nbsp;an&nbsp;empty&nbsp;match.</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">matches</span><span class="op">[</span><span class="num">0</span><span class="op">]</span>&nbsp;<span class="op">==</span>&nbsp;<span class="ident">prevMatchEnd</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;We&nbsp;don&#39;t&nbsp;allow&nbsp;an&nbsp;empty&nbsp;match&nbsp;right</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;after&nbsp;a&nbsp;previous&nbsp;match,&nbsp;so&nbsp;ignore&nbsp;it.</span><br>
<span class="lineno">635</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">accept</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">false</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">var</span>&nbsp;<span class="ident">width</span>&nbsp;<span class="builtintype">int</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;TODO:&nbsp;use&nbsp;step()</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">b</span>&nbsp;<span class="op">==</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">640</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">_</span><span class="op">,</span>&nbsp;<span class="ident">width</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">utf8</span><span class="op">.</span><span class="ident">DecodeRuneInString</span><span class="op">(</span><span class="ident">s</span><span class="op">[</span><span class="ident">pos</span><span class="op">:</span><span class="ident">end</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">_</span><span class="op">,</span>&nbsp;<span class="ident">width</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">utf8</span><span class="op">.</span><span class="ident">DecodeRune</span><span class="op">(</span><span class="ident">b</span><span class="op">[</span><span class="ident">pos</span><span class="op">:</span><span class="ident">end</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">width</span>&nbsp;<span class="op">&gt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">645</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">pos</span>&nbsp;<span class="op">+=</span>&nbsp;<span class="ident">width</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">pos</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">end</span>&nbsp;<span class="op">+</span>&nbsp;<span class="num">1</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">650</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">pos</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">matches</span><span class="op">[</span><span class="num">1</span><span class="op">]</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">prevMatchEnd</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">matches</span><span class="op">[</span><span class="num">1</span><span class="op">]</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">accept</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">655</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">deliver</span><span class="op">(</span><span class="ident">re</span><span class="op">.</span><span class="ident">pad</span><span class="op">(</span><span class="ident">matches</span><span class="op">)</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">i</span><span class="op">++</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno">660</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;Find&nbsp;returns&nbsp;a&nbsp;slice&nbsp;holding&nbsp;the&nbsp;text&nbsp;of&nbsp;the&nbsp;leftmost&nbsp;match&nbsp;in&nbsp;b&nbsp;of&nbsp;the&nbsp;regular&nbsp;expression.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;A&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">Find</span><span class="op">(</span><span class="ident">b</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">a</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">doExecute</span><span class="op">(</span><span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">b</span><span class="op">,</span>&nbsp;<span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="num">2</span><span class="op">)</span><br>
<span class="lineno">665</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">a</span>&nbsp;<span class="op">==</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">b</span><span class="op">[</span><span class="ident">a</span><span class="op">[</span><span class="num">0</span><span class="op">]</span><span class="op">:</span><span class="ident">a</span><span class="op">[</span><span class="num">1</span><span class="op">]</span><span class="op">]</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno">670</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;FindIndex&nbsp;returns&nbsp;a&nbsp;two-element&nbsp;slice&nbsp;of&nbsp;integers&nbsp;defining&nbsp;the&nbsp;location&nbsp;of</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;the&nbsp;leftmost&nbsp;match&nbsp;in&nbsp;b&nbsp;of&nbsp;the&nbsp;regular&nbsp;expression.&nbsp;&nbsp;The&nbsp;match&nbsp;itself&nbsp;is&nbsp;at</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;b[loc[0]:loc[1]].</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;A&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno">675</span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindIndex</span><span class="op">(</span><span class="ident">b</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">)</span>&nbsp;<span class="op">(</span><span class="ident">loc</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">a</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">doExecute</span><span class="op">(</span><span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">b</span><span class="op">,</span>&nbsp;<span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="num">2</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">a</span>&nbsp;<span class="op">==</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">680</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">a</span><span class="op">[</span><span class="num">0</span><span class="op">:</span><span class="num">2</span><span class="op">]</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;FindString&nbsp;returns&nbsp;a&nbsp;string&nbsp;holding&nbsp;the&nbsp;text&nbsp;of&nbsp;the&nbsp;leftmost&nbsp;match&nbsp;in&nbsp;s&nbsp;of&nbsp;the&nbsp;regular</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;expression.&nbsp;&nbsp;If&nbsp;there&nbsp;is&nbsp;no&nbsp;match,&nbsp;the&nbsp;return&nbsp;value&nbsp;is&nbsp;an&nbsp;empty&nbsp;string,</span><br>
<span class="lineno">685</span><span class="comment">//&nbsp;but&nbsp;it&nbsp;will&nbsp;also&nbsp;be&nbsp;empty&nbsp;if&nbsp;the&nbsp;regular&nbsp;expression&nbsp;successfully&nbsp;matches</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;an&nbsp;empty&nbsp;string.&nbsp;&nbsp;Use&nbsp;FindStringIndex&nbsp;or&nbsp;FindStringSubmatch&nbsp;if&nbsp;it&nbsp;is</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;necessary&nbsp;to&nbsp;distinguish&nbsp;these&nbsp;cases.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindString</span><span class="op">(</span><span class="ident">s</span>&nbsp;<span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="builtintype">string</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">a</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">doExecute</span><span class="op">(</span><span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">s</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="num">2</span><span class="op">)</span><br>
<span class="lineno">690</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">a</span>&nbsp;<span class="op">==</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="string">&#34;&#34;</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">s</span><span class="op">[</span><span class="ident">a</span><span class="op">[</span><span class="num">0</span><span class="op">]</span><span class="op">:</span><span class="ident">a</span><span class="op">[</span><span class="num">1</span><span class="op">]</span><span class="op">]</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno">695</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;FindStringIndex&nbsp;returns&nbsp;a&nbsp;two-element&nbsp;slice&nbsp;of&nbsp;integers&nbsp;defining&nbsp;the</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;location&nbsp;of&nbsp;the&nbsp;leftmost&nbsp;match&nbsp;in&nbsp;s&nbsp;of&nbsp;the&nbsp;regular&nbsp;expression.&nbsp;&nbsp;The&nbsp;match</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;itself&nbsp;is&nbsp;at&nbsp;s[loc[0]:loc[1]].</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;A&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno">700</span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindStringIndex</span><span class="op">(</span><span class="ident">s</span>&nbsp;<span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="op">(</span><span class="ident">loc</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">a</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">doExecute</span><span class="op">(</span><span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">s</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="num">2</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">a</span>&nbsp;<span class="op">==</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">705</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">a</span><span class="op">[</span><span class="num">0</span><span class="op">:</span><span class="num">2</span><span class="op">]</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;FindReaderIndex&nbsp;returns&nbsp;a&nbsp;two-element&nbsp;slice&nbsp;of&nbsp;integers&nbsp;defining&nbsp;the</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;location&nbsp;of&nbsp;the&nbsp;leftmost&nbsp;match&nbsp;of&nbsp;the&nbsp;regular&nbsp;expression&nbsp;in&nbsp;text&nbsp;read&nbsp;from</span><br>
<span class="lineno">710</span><span class="comment">//&nbsp;the&nbsp;RuneReader.&nbsp;&nbsp;The&nbsp;match&nbsp;text&nbsp;was&nbsp;found&nbsp;in&nbsp;the&nbsp;input&nbsp;stream&nbsp;at</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;byte&nbsp;offset&nbsp;loc[0]&nbsp;through&nbsp;loc[1]-1.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;A&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindReaderIndex</span><span class="op">(</span><span class="ident">r</span>&nbsp;<span class="ident">io</span><span class="op">.</span><span class="ident">RuneReader</span><span class="op">)</span>&nbsp;<span class="op">(</span><span class="ident">loc</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">a</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">doExecute</span><span class="op">(</span><span class="ident">r</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="num">2</span><span class="op">)</span><br>
<span class="lineno">715</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">a</span>&nbsp;<span class="op">==</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">a</span><span class="op">[</span><span class="num">0</span><span class="op">:</span><span class="num">2</span><span class="op">]</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno">720</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;FindSubmatch&nbsp;returns&nbsp;a&nbsp;slice&nbsp;of&nbsp;slices&nbsp;holding&nbsp;the&nbsp;text&nbsp;of&nbsp;the&nbsp;leftmost</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;match&nbsp;of&nbsp;the&nbsp;regular&nbsp;expression&nbsp;in&nbsp;b&nbsp;and&nbsp;the&nbsp;matches,&nbsp;if&nbsp;any,&nbsp;of&nbsp;its</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;subexpressions,&nbsp;as&nbsp;defined&nbsp;by&nbsp;the&nbsp;&#39;Submatch&#39;&nbsp;descriptions&nbsp;in&nbsp;the&nbsp;package</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;comment.</span><br>
<span class="lineno">725</span><span class="comment">//&nbsp;A&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindSubmatch</span><span class="op">(</span><span class="ident">b</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">a</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">doExecute</span><span class="op">(</span><span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">b</span><span class="op">,</span>&nbsp;<span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">prog</span><span class="op">.</span><span class="ident">NumCap</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">a</span>&nbsp;<span class="op">==</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno">730</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">ret</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="builtinfunc">make</span><span class="op">(</span><span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="num">1</span><span class="op">+</span><span class="ident">re</span><span class="op">.</span><span class="ident">numSubexp</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">for</span>&nbsp;<span class="ident">i</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="keyword">range</span>&nbsp;<span class="ident">ret</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="num">2</span><span class="op">*</span><span class="ident">i</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">a</span><span class="op">)</span>&nbsp;<span class="op">&amp;&amp;</span>&nbsp;<span class="ident">a</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">i</span><span class="op">]</span>&nbsp;<span class="op">&gt;=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">ret</span><span class="op">[</span><span class="ident">i</span><span class="op">]</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">b</span><span class="op">[</span><span class="ident">a</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">i</span><span class="op">]</span><span class="op">:</span><span class="ident">a</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">i</span><span class="op">+</span><span class="num">1</span><span class="op">]</span><span class="op">]</span><br>
<span class="lineno">735</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">ret</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">740</span><span class="comment">//&nbsp;Expand&nbsp;appends&nbsp;template&nbsp;to&nbsp;dst&nbsp;and&nbsp;returns&nbsp;the&nbsp;result;&nbsp;during&nbsp;the</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;append,&nbsp;Expand&nbsp;replaces&nbsp;variables&nbsp;in&nbsp;the&nbsp;template&nbsp;with&nbsp;corresponding</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;matches&nbsp;drawn&nbsp;from&nbsp;src.&nbsp;&nbsp;The&nbsp;match&nbsp;slice&nbsp;should&nbsp;have&nbsp;been&nbsp;returned&nbsp;by</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;FindSubmatchIndex.</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno">745</span><span class="comment">//&nbsp;In&nbsp;the&nbsp;template,&nbsp;a&nbsp;variable&nbsp;is&nbsp;denoted&nbsp;by&nbsp;a&nbsp;substring&nbsp;of&nbsp;the&nbsp;form</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;$name&nbsp;or&nbsp;${name},&nbsp;where&nbsp;name&nbsp;is&nbsp;a&nbsp;non-empty&nbsp;sequence&nbsp;of&nbsp;letters,</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;digits,&nbsp;and&nbsp;underscores.&nbsp;&nbsp;A&nbsp;purely&nbsp;numeric&nbsp;name&nbsp;like&nbsp;$1&nbsp;refers&nbsp;to</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;the&nbsp;submatch&nbsp;with&nbsp;the&nbsp;corresponding&nbsp;index;&nbsp;other&nbsp;names&nbsp;refer&nbsp;to</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;capturing&nbsp;parentheses&nbsp;named&nbsp;with&nbsp;the&nbsp;(?P&lt;name&gt;...)&nbsp;syntax.&nbsp;&nbsp;A</span><br>
<span class="lineno">750</span><span class="comment">//&nbsp;reference&nbsp;to&nbsp;an&nbsp;out&nbsp;of&nbsp;range&nbsp;or&nbsp;unmatched&nbsp;index&nbsp;or&nbsp;a&nbsp;name&nbsp;that&nbsp;is&nbsp;not</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;present&nbsp;in&nbsp;the&nbsp;regular&nbsp;expression&nbsp;is&nbsp;replaced&nbsp;with&nbsp;an&nbsp;empty&nbsp;slice.</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;In&nbsp;the&nbsp;$name&nbsp;form,&nbsp;name&nbsp;is&nbsp;taken&nbsp;to&nbsp;be&nbsp;as&nbsp;long&nbsp;as&nbsp;possible:&nbsp;$1x&nbsp;is</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;equivalent&nbsp;to&nbsp;${1x},&nbsp;not&nbsp;${1}x,&nbsp;and,&nbsp;$10&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;${10},&nbsp;not&nbsp;${1}0.</span><br>
<span class="lineno">755</span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;To&nbsp;insert&nbsp;a&nbsp;literal&nbsp;$&nbsp;in&nbsp;the&nbsp;output,&nbsp;use&nbsp;$$&nbsp;in&nbsp;the&nbsp;template.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">Expand</span><span class="op">(</span><span class="ident">dst</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">template</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">src</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">expand</span><span class="op">(</span><span class="ident">dst</span><span class="op">,</span>&nbsp;<span class="builtintype">string</span><span class="op">(</span><span class="ident">template</span><span class="op">)</span><span class="op">,</span>&nbsp;<span class="ident">src</span><span class="op">,</span>&nbsp;<span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="ident">match</span><span class="op">)</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno">760</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;ExpandString&nbsp;is&nbsp;like&nbsp;Expand&nbsp;but&nbsp;the&nbsp;template&nbsp;and&nbsp;source&nbsp;are&nbsp;strings.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;It&nbsp;appends&nbsp;to&nbsp;and&nbsp;returns&nbsp;a&nbsp;byte&nbsp;slice&nbsp;in&nbsp;order&nbsp;to&nbsp;give&nbsp;the&nbsp;calling</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;code&nbsp;control&nbsp;over&nbsp;allocation.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">ExpandString</span><span class="op">(</span><span class="ident">dst</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">template</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">src</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">765</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">expand</span><span class="op">(</span><span class="ident">dst</span><span class="op">,</span>&nbsp;<span class="ident">template</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">src</span><span class="op">,</span>&nbsp;<span class="ident">match</span><span class="op">)</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">expand</span><span class="op">(</span><span class="ident">dst</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">template</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">bsrc</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">src</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">for</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">template</span><span class="op">)</span>&nbsp;<span class="op">&gt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">770</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">i</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">strings</span><span class="op">.</span><span class="ident">Index</span><span class="op">(</span><span class="ident">template</span><span class="op">,</span>&nbsp;<span class="string">&#34;$&#34;</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">i</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">break</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">dst</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">dst</span><span class="op">,</span>&nbsp;<span class="ident">template</span><span class="op">[</span><span class="op">:</span><span class="ident">i</span><span class="op">]</span><span class="op">...</span><span class="op">)</span><br>
<span class="lineno">775</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">template</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">template</span><span class="op">[</span><span class="ident">i</span><span class="op">:</span><span class="op">]</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">template</span><span class="op">)</span>&nbsp;<span class="op">&gt;</span>&nbsp;<span class="num">1</span>&nbsp;<span class="op">&amp;&amp;</span>&nbsp;<span class="ident">template</span><span class="op">[</span><span class="num">1</span><span class="op">]</span>&nbsp;<span class="op">==</span>&nbsp;<span class="string">&#39;$&#39;</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;Treat&nbsp;$$&nbsp;as&nbsp;$.</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">dst</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">dst</span><span class="op">,</span>&nbsp;<span class="string">&#39;$&#39;</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">template</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">template</span><span class="op">[</span><span class="num">2</span><span class="op">:</span><span class="op">]</span><br>
<span class="lineno">780</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">continue</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">name</span><span class="op">,</span>&nbsp;<span class="ident">num</span><span class="op">,</span>&nbsp;<span class="ident">rest</span><span class="op">,</span>&nbsp;<span class="ident">ok</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">extract</span><span class="op">(</span><span class="ident">template</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="op">!</span><span class="ident">ok</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;Malformed;&nbsp;treat&nbsp;$&nbsp;as&nbsp;raw&nbsp;text.</span><br>
<span class="lineno">785</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">dst</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">dst</span><span class="op">,</span>&nbsp;<span class="string">&#39;$&#39;</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">template</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">template</span><span class="op">[</span><span class="num">1</span><span class="op">:</span><span class="op">]</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">continue</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">template</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">rest</span><br>
<span class="lineno">790</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">num</span>&nbsp;<span class="op">&gt;=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="num">2</span><span class="op">*</span><span class="ident">num</span><span class="op">+</span><span class="num">1</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">match</span><span class="op">)</span>&nbsp;<span class="op">&amp;&amp;</span>&nbsp;<span class="ident">match</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">num</span><span class="op">]</span>&nbsp;<span class="op">&gt;=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">bsrc</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">dst</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">dst</span><span class="op">,</span>&nbsp;<span class="ident">bsrc</span><span class="op">[</span><span class="ident">match</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">num</span><span class="op">]</span><span class="op">:</span><span class="ident">match</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">num</span><span class="op">+</span><span class="num">1</span><span class="op">]</span><span class="op">]</span><span class="op">...</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">795</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">dst</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">dst</span><span class="op">,</span>&nbsp;<span class="ident">src</span><span class="op">[</span><span class="ident">match</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">num</span><span class="op">]</span><span class="op">:</span><span class="ident">match</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">num</span><span class="op">+</span><span class="num">1</span><span class="op">]</span><span class="op">]</span><span class="op">...</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">for</span>&nbsp;<span class="ident">i</span><span class="op">,</span>&nbsp;<span class="ident">namei</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="keyword">range</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">subexpNames</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">800</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">name</span>&nbsp;<span class="op">==</span>&nbsp;<span class="ident">namei</span>&nbsp;<span class="op">&amp;&amp;</span>&nbsp;<span class="num">2</span><span class="op">*</span><span class="ident">i</span><span class="op">+</span><span class="num">1</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">match</span><span class="op">)</span>&nbsp;<span class="op">&amp;&amp;</span>&nbsp;<span class="ident">match</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">i</span><span class="op">]</span>&nbsp;<span class="op">&gt;=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">bsrc</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">dst</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">dst</span><span class="op">,</span>&nbsp;<span class="ident">bsrc</span><span class="op">[</span><span class="ident">match</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">i</span><span class="op">]</span><span class="op">:</span><span class="ident">match</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">i</span><span class="op">+</span><span class="num">1</span><span class="op">]</span><span class="op">]</span><span class="op">...</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">dst</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">dst</span><span class="op">,</span>&nbsp;<span class="ident">src</span><span class="op">[</span><span class="ident">match</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">i</span><span class="op">]</span><span class="op">:</span><span class="ident">match</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">i</span><span class="op">+</span><span class="num">1</span><span class="op">]</span><span class="op">]</span><span class="op">...</span><span class="op">)</span><br>
<span class="lineno">805</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">break</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">810</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">dst</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">dst</span><span class="op">,</span>&nbsp;<span class="ident">template</span><span class="op">...</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">dst</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">815</span><span class="comment">//&nbsp;extract&nbsp;returns&nbsp;the&nbsp;name&nbsp;from&nbsp;a&nbsp;leading&nbsp;&#34;$name&#34;&nbsp;or&nbsp;&#34;${name}&#34;&nbsp;in&nbsp;str.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;If&nbsp;it&nbsp;is&nbsp;a&nbsp;number,&nbsp;extract&nbsp;returns&nbsp;num&nbsp;set&nbsp;to&nbsp;that&nbsp;number;&nbsp;otherwise&nbsp;num&nbsp;=&nbsp;-1.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="ident">extract</span><span class="op">(</span><span class="ident">str</span>&nbsp;<span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="op">(</span><span class="ident">name</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">num</span>&nbsp;<span class="builtintype">int</span><span class="op">,</span>&nbsp;<span class="ident">rest</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">ok</span>&nbsp;<span class="builtintype">bool</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">str</span><span class="op">)</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="num">2</span>&nbsp;<span class="op">||</span>&nbsp;<span class="ident">str</span><span class="op">[</span><span class="num">0</span><span class="op">]</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="string">&#39;$&#39;</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span><br>
<span class="lineno">820</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">brace</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">false</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">str</span><span class="op">[</span><span class="num">1</span><span class="op">]</span>&nbsp;<span class="op">==</span>&nbsp;<span class="string">&#39;{&#39;</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">brace</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">true</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">str</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">str</span><span class="op">[</span><span class="num">2</span><span class="op">:</span><span class="op">]</span><br>
<span class="lineno">825</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span>&nbsp;<span class="keyword">else</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">str</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">str</span><span class="op">[</span><span class="num">1</span><span class="op">:</span><span class="op">]</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">i</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="num">0</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">for</span>&nbsp;<span class="ident">i</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">str</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">830</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="builtintype">rune</span><span class="op">,</span>&nbsp;<span class="ident">size</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">utf8</span><span class="op">.</span><span class="ident">DecodeRuneInString</span><span class="op">(</span><span class="ident">str</span><span class="op">[</span><span class="ident">i</span><span class="op">:</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="op">!</span><span class="ident">unicode</span><span class="op">.</span><span class="ident">IsLetter</span><span class="op">(</span><span class="builtintype">rune</span><span class="op">)</span>&nbsp;<span class="op">&amp;&amp;</span>&nbsp;<span class="op">!</span><span class="ident">unicode</span><span class="op">.</span><span class="ident">IsDigit</span><span class="op">(</span><span class="builtintype">rune</span><span class="op">)</span>&nbsp;<span class="op">&amp;&amp;</span>&nbsp;<span class="builtintype">rune</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="string">&#39;_&#39;</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">break</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">i</span>&nbsp;<span class="op">+=</span>&nbsp;<span class="ident">size</span><br>
<span class="lineno">835</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">i</span>&nbsp;<span class="op">==</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;empty&nbsp;name&nbsp;is&nbsp;not&nbsp;okay</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">840</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">name</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">str</span><span class="op">[</span><span class="op">:</span><span class="ident">i</span><span class="op">]</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">brace</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">i</span>&nbsp;<span class="op">&gt;=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">str</span><span class="op">)</span>&nbsp;<span class="op">||</span>&nbsp;<span class="ident">str</span><span class="op">[</span><span class="ident">i</span><span class="op">]</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="string">&#39;}&#39;</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;missing&nbsp;closing&nbsp;brace</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span><br>
<span class="lineno">845</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">i</span><span class="op">++</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;Parse&nbsp;number.</span><br>
<span class="lineno">850</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">num</span>&nbsp;<span class="op">=</span>&nbsp;<span class="num">0</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">for</span>&nbsp;<span class="ident">i</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="num">0</span><span class="op">;</span>&nbsp;<span class="ident">i</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">name</span><span class="op">)</span><span class="op">;</span>&nbsp;<span class="ident">i</span><span class="op">++</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">name</span><span class="op">[</span><span class="ident">i</span><span class="op">]</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="string">&#39;0&#39;</span>&nbsp;<span class="op">||</span>&nbsp;<span class="string">&#39;9&#39;</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="ident">name</span><span class="op">[</span><span class="ident">i</span><span class="op">]</span>&nbsp;<span class="op">||</span>&nbsp;<span class="ident">num</span>&nbsp;<span class="op">&gt;=</span>&nbsp;<span class="num">1e8</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">num</span>&nbsp;<span class="op">=</span>&nbsp;<span class="op">-</span><span class="num">1</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">break</span><br>
<span class="lineno">855</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">num</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">num</span><span class="op">*</span><span class="num">10</span>&nbsp;<span class="op">+</span>&nbsp;<span class="builtintype">int</span><span class="op">(</span><span class="ident">name</span><span class="op">[</span><span class="ident">i</span><span class="op">]</span><span class="op">)</span>&nbsp;<span class="op">-</span>&nbsp;<span class="string">&#39;0&#39;</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="comment">//&nbsp;Disallow&nbsp;leading&nbsp;zeros.</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">name</span><span class="op">[</span><span class="num">0</span><span class="op">]</span>&nbsp;<span class="op">==</span>&nbsp;<span class="string">&#39;0&#39;</span>&nbsp;<span class="op">&amp;&amp;</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">name</span><span class="op">)</span>&nbsp;<span class="op">&gt;</span>&nbsp;<span class="num">1</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">860</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">num</span>&nbsp;<span class="op">=</span>&nbsp;<span class="op">-</span><span class="num">1</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">rest</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">str</span><span class="op">[</span><span class="ident">i</span><span class="op">:</span><span class="op">]</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">ok</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">true</span><br>
<span class="lineno">865</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;FindSubmatchIndex&nbsp;returns&nbsp;a&nbsp;slice&nbsp;holding&nbsp;the&nbsp;index&nbsp;pairs&nbsp;identifying&nbsp;the</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;leftmost&nbsp;match&nbsp;of&nbsp;the&nbsp;regular&nbsp;expression&nbsp;in&nbsp;b&nbsp;and&nbsp;the&nbsp;matches,&nbsp;if&nbsp;any,&nbsp;of</span><br>
<span class="lineno">870</span><span class="comment">//&nbsp;its&nbsp;subexpressions,&nbsp;as&nbsp;defined&nbsp;by&nbsp;the&nbsp;&#39;Submatch&#39;&nbsp;and&nbsp;&#39;Index&#39;&nbsp;descriptions</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;in&nbsp;the&nbsp;package&nbsp;comment.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;A&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindSubmatchIndex</span><span class="op">(</span><span class="ident">b</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">pad</span><span class="op">(</span><span class="ident">re</span><span class="op">.</span><span class="ident">doExecute</span><span class="op">(</span><span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">b</span><span class="op">,</span>&nbsp;<span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">prog</span><span class="op">.</span><span class="ident">NumCap</span><span class="op">)</span><span class="op">)</span><br>
<span class="lineno">875</span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;FindStringSubmatch&nbsp;returns&nbsp;a&nbsp;slice&nbsp;of&nbsp;strings&nbsp;holding&nbsp;the&nbsp;text&nbsp;of&nbsp;the</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;leftmost&nbsp;match&nbsp;of&nbsp;the&nbsp;regular&nbsp;expression&nbsp;in&nbsp;s&nbsp;and&nbsp;the&nbsp;matches,&nbsp;if&nbsp;any,&nbsp;of</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;its&nbsp;subexpressions,&nbsp;as&nbsp;defined&nbsp;by&nbsp;the&nbsp;&#39;Submatch&#39;&nbsp;description&nbsp;in&nbsp;the</span><br>
<span class="lineno">880</span><span class="comment">//&nbsp;package&nbsp;comment.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;A&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindStringSubmatch</span><span class="op">(</span><span class="ident">s</span>&nbsp;<span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">string</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">a</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">doExecute</span><span class="op">(</span><span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">s</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">prog</span><span class="op">.</span><span class="ident">NumCap</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">a</span>&nbsp;<span class="op">==</span>&nbsp;<span class="ident">nil</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">885</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">ret</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="builtinfunc">make</span><span class="op">(</span><span class="op">[</span><span class="op">]</span><span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="num">1</span><span class="op">+</span><span class="ident">re</span><span class="op">.</span><span class="ident">numSubexp</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">for</span>&nbsp;<span class="ident">i</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="keyword">range</span>&nbsp;<span class="ident">ret</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="num">2</span><span class="op">*</span><span class="ident">i</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">a</span><span class="op">)</span>&nbsp;<span class="op">&amp;&amp;</span>&nbsp;<span class="ident">a</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">i</span><span class="op">]</span>&nbsp;<span class="op">&gt;=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">890</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">ret</span><span class="op">[</span><span class="ident">i</span><span class="op">]</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">s</span><span class="op">[</span><span class="ident">a</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">i</span><span class="op">]</span><span class="op">:</span><span class="ident">a</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">i</span><span class="op">+</span><span class="num">1</span><span class="op">]</span><span class="op">]</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">ret</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno">895</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;FindStringSubmatchIndex&nbsp;returns&nbsp;a&nbsp;slice&nbsp;holding&nbsp;the&nbsp;index&nbsp;pairs</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;identifying&nbsp;the&nbsp;leftmost&nbsp;match&nbsp;of&nbsp;the&nbsp;regular&nbsp;expression&nbsp;in&nbsp;s&nbsp;and&nbsp;the</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;matches,&nbsp;if&nbsp;any,&nbsp;of&nbsp;its&nbsp;subexpressions,&nbsp;as&nbsp;defined&nbsp;by&nbsp;the&nbsp;&#39;Submatch&#39;&nbsp;and</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;&#39;Index&#39;&nbsp;descriptions&nbsp;in&nbsp;the&nbsp;package&nbsp;comment.</span><br>
<span class="lineno">900</span><span class="comment">//&nbsp;A&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindStringSubmatchIndex</span><span class="op">(</span><span class="ident">s</span>&nbsp;<span class="builtintype">string</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">pad</span><span class="op">(</span><span class="ident">re</span><span class="op">.</span><span class="ident">doExecute</span><span class="op">(</span><span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">s</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">prog</span><span class="op">.</span><span class="ident">NumCap</span><span class="op">)</span><span class="op">)</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">905</span><span class="comment">//&nbsp;FindReaderSubmatchIndex&nbsp;returns&nbsp;a&nbsp;slice&nbsp;holding&nbsp;the&nbsp;index&nbsp;pairs</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;identifying&nbsp;the&nbsp;leftmost&nbsp;match&nbsp;of&nbsp;the&nbsp;regular&nbsp;expression&nbsp;of&nbsp;text&nbsp;read&nbsp;by</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;the&nbsp;RuneReader,&nbsp;and&nbsp;the&nbsp;matches,&nbsp;if&nbsp;any,&nbsp;of&nbsp;its&nbsp;subexpressions,&nbsp;as&nbsp;defined</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;by&nbsp;the&nbsp;&#39;Submatch&#39;&nbsp;and&nbsp;&#39;Index&#39;&nbsp;descriptions&nbsp;in&nbsp;the&nbsp;package&nbsp;comment.&nbsp;&nbsp;A</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno">910</span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindReaderSubmatchIndex</span><span class="op">(</span><span class="ident">r</span>&nbsp;<span class="ident">io</span><span class="op">.</span><span class="ident">RuneReader</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">pad</span><span class="op">(</span><span class="ident">re</span><span class="op">.</span><span class="ident">doExecute</span><span class="op">(</span><span class="ident">r</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">prog</span><span class="op">.</span><span class="ident">NumCap</span><span class="op">)</span><span class="op">)</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="keyword">const</span>&nbsp;<span class="ident">startSize</span>&nbsp;<span class="op">=</span>&nbsp;<span class="num">10</span>&nbsp;<span class="comment">//&nbsp;The&nbsp;size&nbsp;at&nbsp;which&nbsp;to&nbsp;start&nbsp;a&nbsp;slice&nbsp;in&nbsp;the&nbsp;&#39;All&#39;&nbsp;routines.</span><br>
<span class="lineno">915</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;FindAll&nbsp;is&nbsp;the&nbsp;&#39;All&#39;&nbsp;version&nbsp;of&nbsp;Find;&nbsp;it&nbsp;returns&nbsp;a&nbsp;slice&nbsp;of&nbsp;all&nbsp;successive</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;matches&nbsp;of&nbsp;the&nbsp;expression,&nbsp;as&nbsp;defined&nbsp;by&nbsp;the&nbsp;&#39;All&#39;&nbsp;description&nbsp;in&nbsp;the</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;package&nbsp;comment.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;A&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno">920</span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindAll</span><span class="op">(</span><span class="ident">b</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">n</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">b</span><span class="op">)</span>&nbsp;<span class="op">+</span>&nbsp;<span class="num">1</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">result</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="builtinfunc">make</span><span class="op">(</span><span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="ident">startSize</span><span class="op">)</span><br>
<span class="lineno">925</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">.</span><span class="ident">allMatches</span><span class="op">(</span><span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="ident">b</span><span class="op">,</span>&nbsp;<span class="ident">n</span><span class="op">,</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">result</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">result</span><span class="op">,</span>&nbsp;<span class="ident">b</span><span class="op">[</span><span class="ident">match</span><span class="op">[</span><span class="num">0</span><span class="op">]</span><span class="op">:</span><span class="ident">match</span><span class="op">[</span><span class="num">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">result</span><span class="op">)</span>&nbsp;<span class="op">==</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno">930</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">result</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;FindAllIndex&nbsp;is&nbsp;the&nbsp;&#39;All&#39;&nbsp;version&nbsp;of&nbsp;FindIndex;&nbsp;it&nbsp;returns&nbsp;a&nbsp;slice&nbsp;of&nbsp;all</span><br>
<span class="lineno">935</span><span class="comment">//&nbsp;successive&nbsp;matches&nbsp;of&nbsp;the&nbsp;expression,&nbsp;as&nbsp;defined&nbsp;by&nbsp;the&nbsp;&#39;All&#39;&nbsp;description</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;in&nbsp;the&nbsp;package&nbsp;comment.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;A&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindAllIndex</span><span class="op">(</span><span class="ident">b</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">int</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">940</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">n</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">b</span><span class="op">)</span>&nbsp;<span class="op">+</span>&nbsp;<span class="num">1</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">result</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="builtinfunc">make</span><span class="op">(</span><span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="ident">startSize</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">.</span><span class="ident">allMatches</span><span class="op">(</span><span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="ident">b</span><span class="op">,</span>&nbsp;<span class="ident">n</span><span class="op">,</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">result</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">result</span><span class="op">,</span>&nbsp;<span class="ident">match</span><span class="op">[</span><span class="num">0</span><span class="op">:</span><span class="num">2</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno">945</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">result</span><span class="op">)</span>&nbsp;<span class="op">==</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">result</span><br>
<span class="lineno">950</span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;FindAllString&nbsp;is&nbsp;the&nbsp;&#39;All&#39;&nbsp;version&nbsp;of&nbsp;FindString;&nbsp;it&nbsp;returns&nbsp;a&nbsp;slice&nbsp;of&nbsp;all</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;successive&nbsp;matches&nbsp;of&nbsp;the&nbsp;expression,&nbsp;as&nbsp;defined&nbsp;by&nbsp;the&nbsp;&#39;All&#39;&nbsp;description</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;in&nbsp;the&nbsp;package&nbsp;comment.</span><br>
<span class="lineno">955</span><span class="comment">//&nbsp;A&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindAllString</span><span class="op">(</span><span class="ident">s</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">string</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">n</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">s</span><span class="op">)</span>&nbsp;<span class="op">+</span>&nbsp;<span class="num">1</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">960</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">result</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="builtinfunc">make</span><span class="op">(</span><span class="op">[</span><span class="op">]</span><span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="ident">startSize</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">.</span><span class="ident">allMatches</span><span class="op">(</span><span class="ident">s</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">n</span><span class="op">,</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">result</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">result</span><span class="op">,</span>&nbsp;<span class="ident">s</span><span class="op">[</span><span class="ident">match</span><span class="op">[</span><span class="num">0</span><span class="op">]</span><span class="op">:</span><span class="ident">match</span><span class="op">[</span><span class="num">1</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">result</span><span class="op">)</span>&nbsp;<span class="op">==</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">965</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">result</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">970</span><span class="comment">//&nbsp;FindAllStringIndex&nbsp;is&nbsp;the&nbsp;&#39;All&#39;&nbsp;version&nbsp;of&nbsp;FindStringIndex;&nbsp;it&nbsp;returns&nbsp;a</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;slice&nbsp;of&nbsp;all&nbsp;successive&nbsp;matches&nbsp;of&nbsp;the&nbsp;expression,&nbsp;as&nbsp;defined&nbsp;by&nbsp;the&nbsp;&#39;All&#39;</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;description&nbsp;in&nbsp;the&nbsp;package&nbsp;comment.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;A&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindAllStringIndex</span><span class="op">(</span><span class="ident">s</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">int</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">975</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">n</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">s</span><span class="op">)</span>&nbsp;<span class="op">+</span>&nbsp;<span class="num">1</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">result</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="builtinfunc">make</span><span class="op">(</span><span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="ident">startSize</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">.</span><span class="ident">allMatches</span><span class="op">(</span><span class="ident">s</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">n</span><span class="op">,</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">980</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">result</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">result</span><span class="op">,</span>&nbsp;<span class="ident">match</span><span class="op">[</span><span class="num">0</span><span class="op">:</span><span class="num">2</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">result</span><span class="op">)</span>&nbsp;<span class="op">==</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">985</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">result</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;FindAllSubmatch&nbsp;is&nbsp;the&nbsp;&#39;All&#39;&nbsp;version&nbsp;of&nbsp;FindSubmatch;&nbsp;it&nbsp;returns&nbsp;a&nbsp;slice</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;of&nbsp;all&nbsp;successive&nbsp;matches&nbsp;of&nbsp;the&nbsp;expression,&nbsp;as&nbsp;defined&nbsp;by&nbsp;the&nbsp;&#39;All&#39;</span><br>
<span class="lineno">990</span><span class="comment">//&nbsp;description&nbsp;in&nbsp;the&nbsp;package&nbsp;comment.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;A&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindAllSubmatch</span><span class="op">(</span><span class="ident">b</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">n</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">b</span><span class="op">)</span>&nbsp;<span class="op">+</span>&nbsp;<span class="num">1</span><br>
<span class="lineno">995</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">result</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="builtinfunc">make</span><span class="op">(</span><span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="ident">startSize</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">.</span><span class="ident">allMatches</span><span class="op">(</span><span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="ident">b</span><span class="op">,</span>&nbsp;<span class="ident">n</span><span class="op">,</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">slice</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="builtinfunc">make</span><span class="op">(</span><span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">match</span><span class="op">)</span><span class="op">/</span><span class="num">2</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">for</span>&nbsp;<span class="ident">j</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="keyword">range</span>&nbsp;<span class="ident">slice</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">1000</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">match</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">j</span><span class="op">]</span>&nbsp;<span class="op">&gt;=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">slice</span><span class="op">[</span><span class="ident">j</span><span class="op">]</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">b</span><span class="op">[</span><span class="ident">match</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">j</span><span class="op">]</span><span class="op">:</span><span class="ident">match</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">j</span><span class="op">+</span><span class="num">1</span><span class="op">]</span><span class="op">]</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">result</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">result</span><span class="op">,</span>&nbsp;<span class="ident">slice</span><span class="op">)</span><br>
<span class="lineno">1005</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">result</span><span class="op">)</span>&nbsp;<span class="op">==</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">result</span><br>
<span class="lineno">1010</span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;FindAllSubmatchIndex&nbsp;is&nbsp;the&nbsp;&#39;All&#39;&nbsp;version&nbsp;of&nbsp;FindSubmatchIndex;&nbsp;it&nbsp;returns</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;a&nbsp;slice&nbsp;of&nbsp;all&nbsp;successive&nbsp;matches&nbsp;of&nbsp;the&nbsp;expression,&nbsp;as&nbsp;defined&nbsp;by&nbsp;the</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;&#39;All&#39;&nbsp;description&nbsp;in&nbsp;the&nbsp;package&nbsp;comment.</span><br>
<span class="lineno">1015</span><span class="comment">//&nbsp;A&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindAllSubmatchIndex</span><span class="op">(</span><span class="ident">b</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">byte</span><span class="op">,</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">int</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">n</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">b</span><span class="op">)</span>&nbsp;<span class="op">+</span>&nbsp;<span class="num">1</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">1020</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">result</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="builtinfunc">make</span><span class="op">(</span><span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="ident">startSize</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">.</span><span class="ident">allMatches</span><span class="op">(</span><span class="string">&#34;&#34;</span><span class="op">,</span>&nbsp;<span class="ident">b</span><span class="op">,</span>&nbsp;<span class="ident">n</span><span class="op">,</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">result</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">result</span><span class="op">,</span>&nbsp;<span class="ident">match</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">result</span><span class="op">)</span>&nbsp;<span class="op">==</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">1025</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">result</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">1030</span><span class="comment">//&nbsp;FindAllStringSubmatch&nbsp;is&nbsp;the&nbsp;&#39;All&#39;&nbsp;version&nbsp;of&nbsp;FindStringSubmatch;&nbsp;it</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;returns&nbsp;a&nbsp;slice&nbsp;of&nbsp;all&nbsp;successive&nbsp;matches&nbsp;of&nbsp;the&nbsp;expression,&nbsp;as&nbsp;defined&nbsp;by</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;the&nbsp;&#39;All&#39;&nbsp;description&nbsp;in&nbsp;the&nbsp;package&nbsp;comment.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;A&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindAllStringSubmatch</span><span class="op">(</span><span class="ident">s</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">string</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">1035</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">n</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">s</span><span class="op">)</span>&nbsp;<span class="op">+</span>&nbsp;<span class="num">1</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">result</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="builtinfunc">make</span><span class="op">(</span><span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="ident">startSize</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">.</span><span class="ident">allMatches</span><span class="op">(</span><span class="ident">s</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">n</span><span class="op">,</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">1040</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">slice</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="builtinfunc">make</span><span class="op">(</span><span class="op">[</span><span class="op">]</span><span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">match</span><span class="op">)</span><span class="op">/</span><span class="num">2</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">for</span>&nbsp;<span class="ident">j</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="keyword">range</span>&nbsp;<span class="ident">slice</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">match</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">j</span><span class="op">]</span>&nbsp;<span class="op">&gt;=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">slice</span><span class="op">[</span><span class="ident">j</span><span class="op">]</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">s</span><span class="op">[</span><span class="ident">match</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">j</span><span class="op">]</span><span class="op">:</span><span class="ident">match</span><span class="op">[</span><span class="num">2</span><span class="op">*</span><span class="ident">j</span><span class="op">+</span><span class="num">1</span><span class="op">]</span><span class="op">]</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">1045</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">result</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">result</span><span class="op">,</span>&nbsp;<span class="ident">slice</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">result</span><span class="op">)</span>&nbsp;<span class="op">==</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno">1050</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">result</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;FindAllStringSubmatchIndex&nbsp;is&nbsp;the&nbsp;&#39;All&#39;&nbsp;version&nbsp;of</span><br>
<span class="lineno">1055</span><span class="comment">//&nbsp;FindStringSubmatchIndex;&nbsp;it&nbsp;returns&nbsp;a&nbsp;slice&nbsp;of&nbsp;all&nbsp;successive&nbsp;matches&nbsp;of</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;the&nbsp;expression,&nbsp;as&nbsp;defined&nbsp;by&nbsp;the&nbsp;&#39;All&#39;&nbsp;description&nbsp;in&nbsp;the&nbsp;package</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;comment.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;A&nbsp;return&nbsp;value&nbsp;of&nbsp;nil&nbsp;indicates&nbsp;no&nbsp;match.</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">FindAllStringSubmatchIndex</span><span class="op">(</span><span class="ident">s</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">int</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">1060</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="op">&lt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">n</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">s</span><span class="op">)</span>&nbsp;<span class="op">+</span>&nbsp;<span class="num">1</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">result</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="builtinfunc">make</span><span class="op">(</span><span class="op">[</span><span class="op">]</span><span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="ident">startSize</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">re</span><span class="op">.</span><span class="ident">allMatches</span><span class="op">(</span><span class="ident">s</span><span class="op">,</span>&nbsp;<span class="ident">nil</span><span class="op">,</span>&nbsp;<span class="ident">n</span><span class="op">,</span>&nbsp;<span class="keyword">func</span><span class="op">(</span><span class="ident">match</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">1065</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">result</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">result</span><span class="op">,</span>&nbsp;<span class="ident">match</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">result</span><span class="op">)</span>&nbsp;<span class="op">==</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno">1070</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">result</span><br>
<span class="lineno"></span><span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span><span class="comment">//&nbsp;Split&nbsp;slices&nbsp;s&nbsp;into&nbsp;substrings&nbsp;separated&nbsp;by&nbsp;the&nbsp;expression&nbsp;and&nbsp;returns&nbsp;a&nbsp;slice&nbsp;of</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;the&nbsp;substrings&nbsp;between&nbsp;those&nbsp;expression&nbsp;matches.</span><br>
<span class="lineno">1075</span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;The&nbsp;slice&nbsp;returned&nbsp;by&nbsp;this&nbsp;method&nbsp;consists&nbsp;of&nbsp;all&nbsp;the&nbsp;substrings&nbsp;of&nbsp;s</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;not&nbsp;contained&nbsp;in&nbsp;the&nbsp;slice&nbsp;returned&nbsp;by&nbsp;FindAllString.&nbsp;When&nbsp;called&nbsp;on&nbsp;an&nbsp;expression</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;that&nbsp;contains&nbsp;no&nbsp;metacharacters,&nbsp;it&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;strings.SplitN.</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno">1080</span><span class="comment">//&nbsp;Example:</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;&nbsp;&nbsp;s&nbsp;:=&nbsp;regexp.MustCompile(&#34;a*&#34;).Split(&#34;abaabaccadaaae&#34;,&nbsp;5)</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;&nbsp;&nbsp;//&nbsp;s:&nbsp;[&#34;&#34;,&nbsp;&#34;b&#34;,&nbsp;&#34;b&#34;,&nbsp;&#34;c&#34;,&nbsp;&#34;cadaaae&#34;]</span><br>
<span class="lineno"></span><span class="comment">//</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;The&nbsp;count&nbsp;determines&nbsp;the&nbsp;number&nbsp;of&nbsp;substrings&nbsp;to&nbsp;return:</span><br>
<span class="lineno">1085</span><span class="comment">//&nbsp;&nbsp;&nbsp;n&nbsp;&gt;&nbsp;0:&nbsp;at&nbsp;most&nbsp;n&nbsp;substrings;&nbsp;the&nbsp;last&nbsp;substring&nbsp;will&nbsp;be&nbsp;the&nbsp;unsplit&nbsp;remainder.</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;&nbsp;&nbsp;n&nbsp;==&nbsp;0:&nbsp;the&nbsp;result&nbsp;is&nbsp;nil&nbsp;(zero&nbsp;substrings)</span><br>
<span class="lineno"></span><span class="comment">//&nbsp;&nbsp;&nbsp;n&nbsp;&lt;&nbsp;0:&nbsp;all&nbsp;substrings</span><br>
<span class="lineno"></span><span class="keyword">func</span>&nbsp;<span class="op">(</span><span class="ident">re</span>&nbsp;<span class="op">*</span><span class="ident">Regexp</span><span class="op">)</span>&nbsp;<span class="ident">Split</span><span class="op">(</span><span class="ident">s</span>&nbsp;<span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="builtintype">int</span><span class="op">)</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">string</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span><br>
<span class="lineno">1090</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="op">==</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">nil</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">re</span><span class="op">.</span><span class="ident">expr</span><span class="op">)</span>&nbsp;<span class="op">&gt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">&amp;&amp;</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">s</span><span class="op">)</span>&nbsp;<span class="op">==</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">1095</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="op">[</span><span class="op">]</span><span class="builtintype">string</span><span class="op">{</span><span class="string">&#34;&#34;</span><span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">matches</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="ident">re</span><span class="op">.</span><span class="ident">FindAllStringIndex</span><span class="op">(</span><span class="ident">s</span><span class="op">,</span>&nbsp;<span class="ident">n</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">strings</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="builtinfunc">make</span><span class="op">(</span><span class="op">[</span><span class="op">]</span><span class="builtintype">string</span><span class="op">,</span>&nbsp;<span class="num">0</span><span class="op">,</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">matches</span><span class="op">)</span><span class="op">)</span><br>
<span class="lineno">1100</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">beg</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="num">0</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">end</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="num">0</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">for</span>&nbsp;<span class="ident">_</span><span class="op">,</span>&nbsp;<span class="ident">match</span>&nbsp;<span class="op">:=</span>&nbsp;<span class="keyword">range</span>&nbsp;<span class="ident">matches</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">n</span>&nbsp;<span class="op">&gt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">&amp;&amp;</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">strings</span><span class="op">)</span>&nbsp;<span class="op">&gt;=</span>&nbsp;<span class="ident">n</span><span class="op">-</span><span class="num">1</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">1105</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">break</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">end</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">match</span><span class="op">[</span><span class="num">0</span><span class="op">]</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">match</span><span class="op">[</span><span class="num">1</span><span class="op">]</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="op">{</span><br>
<span class="lineno">1110</span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">strings</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">strings</span><span class="op">,</span>&nbsp;<span class="ident">s</span><span class="op">[</span><span class="ident">beg</span><span class="op">:</span><span class="ident">end</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">beg</span>&nbsp;<span class="op">=</span>&nbsp;<span class="ident">match</span><span class="op">[</span><span class="num">1</span><span class="op">]</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno">1115</span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">if</span>&nbsp;<span class="ident">end</span>&nbsp;<span class="op">!=</span>&nbsp;<span class="builtinfunc">len</span><span class="op">(</span><span class="ident">s</span><span class="op">)</span>&nbsp;<span class="op">{</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp;&nbsp;&nbsp<span class="ident">strings</span>&nbsp;<span class="op">=</span>&nbsp;<span class="builtinfunc">append</span><span class="op">(</span><span class="ident">strings</span><span class="op">,</span>&nbsp;<span class="ident">s</span><span class="op">[</span><span class="ident">beg</span><span class="op">:</span><span class="op">]</span><span class="op">)</span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="op">}</span><br>
<span class="lineno"></span><br>
<span class="lineno"></span>&nbsp;&nbsp;&nbsp;&nbsp<span class="keyword">return</span>&nbsp;<span class="ident">strings</span><br>
<span class="lineno">1120</span><span class="op">}</span>
</div>
</body>
</html>
